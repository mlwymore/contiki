<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">

<title>Hardware Abstraction Level: Token</title>

<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">

</head><body>

<table border="0" cellspacing="0" cellpadding="0"  width=100%>

<tr>

<td><img src="ST_Logo.gif"></td>

<td> <div class="qindex">

<a class="qindex" href="index.html">Home</a>&nbsp;

 | &nbsp;<a class="qindex" href="modules.html">Modules</a>&nbsp;

 | &nbsp;<a class="qindex" href="annotated.html">Data Structures</a>&nbsp;

 | &nbsp;<a class="qindex" href="files.html">File List</a>&nbsp;

 | &nbsp;<a class="qindex" href="globals.html">Index</a></div>

</td>

</table>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Token</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__token.html#ga04be523f62a6ea7fbf6e11af7bf5f8e7">INVALID_EE_ADDRESS</a>&nbsp;&nbsp;&nbsp;0xFFFF</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__micro.html#gafddf1f4a9c9eff790d56c8950c1fb0ad">StStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__token.html#ga2025874bb293635b82d3f213e5dfa8fd">halStackInitTokens</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes and enables the token system. Checks if the manufacturing and stack non-volatile data versions are correct.  <a href="#ga2025874bb293635b82d3f213e5dfa8fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__iar.html#ga409a5c4bea6981c30b308684efa33f6f">int16u</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__token.html#ga97809a36ff4913d2b2b5a10c3c8d095e">getTokenAddress</a> (<a class="el" href="group__iar.html#ga409a5c4bea6981c30b308684efa33f6f">int16u</a> creator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__iar.html#gae712ac7a6479b38bdbb3286e80b72049">int8u</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__token.html#ga8cff2de5e2bd5d8538ead7b99bfdcc09">getTokenSize</a> (<a class="el" href="group__iar.html#ga409a5c4bea6981c30b308684efa33f6f">int16u</a> creator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__iar.html#gae712ac7a6479b38bdbb3286e80b72049">int8u</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__token.html#gac45869bc1a72fee6ca8341a92cef1079">getTokenArraySize</a> (<a class="el" href="group__iar.html#ga409a5c4bea6981c30b308684efa33f6f">int16u</a> creator)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>There are three main types of tokens:</p>
<ul>
<li><b>Manufacturing tokens:</b> Tokens that are set at the factory and must not be changed through software operations.</li>
<li><b>Stack-level tokens:</b> Tokens that can be changed via the appropriate stack API calls.</li>
<li><b>Application level tokens:</b> Tokens that can be set via the token system API calls in this file.</li>
</ul>
<p>The token system API controls writing non-volatile data to and reading non-volatile data from the EEPROM. If an application wishes to use non-volatile memory, it must do so by creating its own token header file similar to token-stack.h. The macro <code>APPLICATION_TOKEN_HEADER</code> should be defined to equal the name of the header file in which application tokens are defined.</p>
<p>Because the token system is based on memory locations within the EEPROM, the token information could become out of sync without some kind of version tracking. The two defines, <code>CURRENT_MFG_TOKEN_VERSION </code> and <code>CURRENT_STACK_TOKEN_VERSION</code>, are used to make sure the stack stays in sync with the proper token set in the proper locations.</p>
<p>The most general format of a token definition is:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #define CREATOR_name 16bit_value</span>
<span class="preprocessor"></span><span class="preprocessor"> #ifdef DEFINETYPES</span>
<span class="preprocessor"></span>    <span class="keyword">typedef</span> data_type type
<span class="preprocessor"> #endif //DEFINETYPES</span>
<span class="preprocessor"></span><span class="preprocessor"> #ifdef DEFINETOKENS</span>
<span class="preprocessor"></span>    DEFINE_*_TOKEN(name, type, ... ,defaults)
 <span class="preprocessor">#endif //DEFINETOKENS</span>
</pre></div><p>The defined CREATOR is used as a distinct identifier tag for the token. The CREATOR is necessary because the token name is defined differently depending on the hardware platform, so the CREATOR makes sure token definitions and data stay tagged and known. The only requirement on these creator definitions is that they all must be unique. A favorite method for picking creator codes is to use two ASCII characters inorder to make the codes more memorable. The 'name' part of the <code>#define CREATOR_name</code> must match the 'name' provided in the <code>DEFINE_*_TOKEN</code> because the token system uses this name to automatically link the two.</p>
<p>The typedef provides a convenient and efficient abstraction of the token data. Since some tokens are structs with multiple pieces of data inside of them, type defining the token type allows more efficient and readable local copies of the tokens throughout the code.</p>
<p>The typedef is wrapped with an <code>#ifdef DEFINETYPES</code> because the typdefs and token defs live in the same file, and DEFINETYPES is used to select only the typedefs when the file is included. Similarly, the <code>DEFINE_*_TOKEN</code> is wrapped with an <code>#ifdef DEFINETOKENS</code> as a method for selecting only the token definitions when the file is included.</p>
<p>The abstract definition, <code>DEFINE_*_TOKEN(name, type, ... ,defaults)</code>, has seven possible complete definitions:<br/>
 <code> </p>
<ul>
<li>
DEFINE_BASIC_TOKEN(name, type, ...) </li>
<li>
DEFINE_INDEXED_TOKEN(name, type, arraysize, ...) </li>
<li>
DEFINE_COUNTER_TOKEN(name, type, ...) </li>
<li>
DEFINE_FIXED_BASIC_TOKEN(name, type, address, ...) </li>
<li>
DEFINE_FIXED_INDEXED_TOKEN(name, type, arraysize, address, ...) </li>
<li>
DEFINE_FIXED_COUNTER_TOKEN(name, type, address, ...) </li>
<li>
DEFINE_MFG_TOKEN(name, type, address, ...) </li>
</ul>
<p></code> The three fields common to all <code>DEFINE_*_TOKEN</code> are: name - The name of the token, which all information is tied to. type - Type of the token which is the same as the typedef mentioned before. ... - The default value to which the token is set upon initialization.</p>
<p>The difference between a FIXED and non-fixed token is the address at which the token is stored. For a FIXED token, the address is explicitly provided in the token definition in the field: address - Where the token is stored. Do not conflict with other tokens! A non-fixed token is dynamically placed. Dynamic token placement begins in the application token region which is directly above stack tokens. Dynamic placement will pack the tokens directly next to eachother, as far down in memory as possible until they hit a FIXED token.<br/>
<br/>
</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Be very careful when mixing FIXED tokens with non-fixed tokens! Placing a FIXED token above dynamic tokens, but not far enough above them, could cause token overlap! Whenever the token set is changed, the Token Utility application should not only be used to load in the new set of default tokens, but it can also be used to view the token memory map for any overlaps or conflicts.</dd></dl>
<p><b>BASIC_TOKEN</b> is the simplest definition and will be used for the majority of tokens - tokens that are not indexed and are not counters.</p>
<p><b>INDEXED_TOKEN</b> should be used on tokens that look like arrays. For example, data storage that looks like:<br/>
 </p>
<pre><code>   int32u myData[5]</code></pre><p><br/>
 can be a token with typedef of int32u and defined as INDEXED with arraysize of 5. The extra field in this token definition is: arraysize - The number of elements in the indexed token.</p>
<p><b>COUNTER_TOKEN</b> should be used on tokens that are simple numbers. The reason for using COUNTER_TOKEN instead of BASIC_TOKEN is the special support that the token system provides for counters. The function call <code>halCommonIncrementCounterToken()</code> only operates on counter tokens and is more efficient for incrementing simple numbers in the token system.</p>
<p><b>DEFINE_MFG_TOKEN</b> operates almost identically to DEFINE_FIXED_BASIC_TOKEN, in that it defines a simple scalar token at a specific address. The major difference is this token is designated manufacturing, which means certain functions and utilities treat it differently from stack or app tokens. For example, the Token Utility has commands for loading default values, and these commands make a distinction between manufacturing versus non manufacturing tokens (since generally manufacturing tokens should never be changed or reset).</p>
<p>Here is an example of two application tokens:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #define CREATOR_SENSOR_NAME        0x5354</span>
<span class="preprocessor"></span><span class="preprocessor"> #define CREATOR_SENSOR_PARAMETERS  0x5350</span>
<span class="preprocessor"></span><span class="preprocessor"> #ifdef DEFINETYPES</span>
<span class="preprocessor"></span>   <span class="keyword">typedef</span> <a class="code" href="group__gnu.html#gae712ac7a6479b38bdbb3286e80b72049">int8u</a> tokTypeSensorName[10];
   <span class="keyword">typedef</span> <span class="keyword">struct </span>{
     <a class="code" href="group__gnu.html#gae712ac7a6479b38bdbb3286e80b72049">int8u</a> initValues[5];
     <a class="code" href="group__gnu.html#gae712ac7a6479b38bdbb3286e80b72049">int8u</a> reportInterval;
     <a class="code" href="group__gnu.html#ga409a5c4bea6981c30b308684efa33f6f">int16u</a> calibrationValue;
   } tokTypeSensorParameters;
<span class="preprocessor"> #endif //DEFINETYPES</span>
<span class="preprocessor"></span><span class="preprocessor"> #ifdef DEFINETOKENS</span>
<span class="preprocessor"></span>   DEFINE_BASIC_TOKEN(SENSOR_NAME,
                      tokTypeSensorName,
                      {<span class="charliteral">&apos;U&apos;</span>,<span class="charliteral">&apos;N&apos;</span>,<span class="charliteral">&apos;A&apos;</span>,<span class="charliteral">&apos;M&apos;</span>,<span class="charliteral">&apos;E&apos;</span>,<span class="charliteral">&apos;D&apos;</span>,<span class="charliteral">&apos; &apos;</span>,<span class="charliteral">&apos; &apos;</span>,<span class="charliteral">&apos; &apos;</span>,<span class="charliteral">&apos; &apos;</span>})
   DEFINE_BASIC_TOKEN(SENSOR_PARAMETERS,
                      tokTypeSensorParameters,
                      {{0x01,0x02,0x03,0x04,0x05},5,0x0000})
 #endif <span class="comment">//DEFINETOKENS</span>
</pre></div><p>And, here is an example of how to use the two application tokens: </p>
<div class="fragment"><pre class="fragment"> {
   tokTypeSensorName sensor;
   tokTypeSensorParameters params;

   halCommonGetToken(&amp;sensor, TOKEN_SENSOR_NAME);
   halCommonGetToken(&amp;params, TOKEN_SENSOR_PARAMETERS);
   <span class="keywordflow">if</span>(params.calibrationValue == 0xBEEF) {
     params.reportInterval = 5;
   }
   halCommonSetToken(TOKEN_SENSOR_PARAMETERS, &amp;params);
 }
</pre></div><p>See token-stack.h to see the default set of tokens and their values.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>A note on token initialization: The Token Utility should be used for initializing tokens (new or changed) and viewing the layout of tokens in storage (to check for conflicts). It is always possible to create an application that will write the initialized values. See the Token Utility source for an example.</dd>
<dd>
Further details on exact implementation can be found in code comments in the stack/config/token-stack.h file, the platform specific <a class="el" href="token-manufacturing_8h.html" title="Definitions for manufacturing tokens.">token-manufacturing.h</a> file, the platform specific <a class="el" href="token_8h.html" title="Token system for storing non-volatile information. See Token for documentation.">token.h</a> file, and the platform specific token.c file.</dd></dl>
<p>Some functions in this file return an <a class="el" href="group__micro.html#gafddf1f4a9c9eff790d56c8950c1fb0ad">StStatus</a> value. See <a class="el" href="error-def_8h.html" title="Return-code definitions for StZNet stack API functions.">error-def.h</a> for definitions of all <a class="el" href="group__micro.html#gafddf1f4a9c9eff790d56c8950c1fb0ad">StStatus</a> return values.</p>
<p>See <a class="el" href="token_8h.html" title="Token system for storing non-volatile information. See Token for documentation.">hal/micro/token.h</a> for source code. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga04be523f62a6ea7fbf6e11af7bf5f8e7"></a><!-- doxytag: member="token.h::INVALID_EE_ADDRESS" ref="ga04be523f62a6ea7fbf6e11af7bf5f8e7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INVALID_EE_ADDRESS&nbsp;&nbsp;&nbsp;0xFFFF</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="token_8h_source.html#l00336">336</a> of file <a class="el" href="token_8h_source.html">token.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga97809a36ff4913d2b2b5a10c3c8d095e"></a><!-- doxytag: member="token.h::getTokenAddress" ref="ga97809a36ff4913d2b2b5a10c3c8d095e" args="(int16u creator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__iar.html#ga409a5c4bea6981c30b308684efa33f6f">int16u</a> getTokenAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iar.html#ga409a5c4bea6981c30b308684efa33f6f">int16u</a>&nbsp;</td>
          <td class="paramname"> <em>creator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gac45869bc1a72fee6ca8341a92cef1079"></a><!-- doxytag: member="token.h::getTokenArraySize" ref="gac45869bc1a72fee6ca8341a92cef1079" args="(int16u creator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__iar.html#gae712ac7a6479b38bdbb3286e80b72049">int8u</a> getTokenArraySize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iar.html#ga409a5c4bea6981c30b308684efa33f6f">int16u</a>&nbsp;</td>
          <td class="paramname"> <em>creator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8cff2de5e2bd5d8538ead7b99bfdcc09"></a><!-- doxytag: member="token.h::getTokenSize" ref="ga8cff2de5e2bd5d8538ead7b99bfdcc09" args="(int16u creator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__iar.html#gae712ac7a6479b38bdbb3286e80b72049">int8u</a> getTokenSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__iar.html#ga409a5c4bea6981c30b308684efa33f6f">int16u</a>&nbsp;</td>
          <td class="paramname"> <em>creator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2025874bb293635b82d3f213e5dfa8fd"></a><!-- doxytag: member="token.h::halStackInitTokens" ref="ga2025874bb293635b82d3f213e5dfa8fd" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__micro.html#gafddf1f4a9c9eff790d56c8950c1fb0ad">StStatus</a> halStackInitTokens </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes and enables the token system. Checks if the manufacturing and stack non-volatile data versions are correct. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An StStatus value indicating the success or failure of the command. </dd></dl>

</div>
</div>
</div>
<hr size="1">

<table border="0" cellspacing="0" cellpadding="0" width=100%>

<tr>

<td><address><small>

Hardware Abstraction Level. <br>

1.0.0.

</small></address>

</td>

<td align="right">

<address><small>

Copyright &copy; 2009 by STMicrolectronics. All rights reserved.<br>

Generated Thu Apr 15 16:02:33 2010 with <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.6.1.

</small></address>

</td>

</tr>

</table>

</body>

</html>
