/*
 * Copyright (c) 2010, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of the Contiki operating system.
 *
 */

/**
 * \file
 *         Implementation of a low-power probing radio duty cycling protocol,
 *         based on contikimac.c.
 * \author
 *         Mat Wymore <mlwymore@gmail.com>
 */

#include "contiki-conf.h"
#include "dev/leds.h"
#include "dev/radio.h"
#include "dev/watchdog.h"
#include "lib/random.h"
#include "net/mac/mac-sequence.h"
#include "net/mac/lpprdc/lpprdc.h"
#include "net/mac/contikimac/contikimac-framer.h"
#include "net/netstack.h"
#include "net/rime/rime.h"
#include "sys/compower.h"
#include "sys/pt.h"
#include "sys/rtimer.h"


#include <string.h>

/* TX/RX cycles are synchronized with neighbor wake periods */
#ifdef CONTIKIMAC_CONF_WITH_PHASE_OPTIMIZATION
#define WITH_PHASE_OPTIMIZATION      CONTIKIMAC_CONF_WITH_PHASE_OPTIMIZATION
#else /* CONTIKIMAC_CONF_WITH_PHASE_OPTIMIZATION */
#define WITH_PHASE_OPTIMIZATION      0
#endif /* CONTIKIMAC_CONF_WITH_PHASE_OPTIMIZATION */
/* More aggressive radio sleeping when channel is busy with other traffic */
#ifndef WITH_FAST_SLEEP
#define WITH_FAST_SLEEP              1
#endif
/* Radio does CSMA and autobackoff */
#ifndef RDC_CONF_HARDWARE_CSMA
#define RDC_CONF_HARDWARE_CSMA       0
#endif
/* Radio returns TX_OK/TX_NOACK after autoack wait */
#ifndef RDC_CONF_HARDWARE_ACK
#define RDC_CONF_HARDWARE_ACK        0
#endif
/* MCU can sleep during radio off */
#ifndef RDC_CONF_MCU_SLEEP
#define RDC_CONF_MCU_SLEEP           0
#endif

/* Are we currently receiving a burst? */
static int we_are_receiving_burst = 0;

/* INTER_PACKET_DEADLINE is the maximum time a receiver waits for the
   next packet of a burst when FRAME_PENDING is set. */
#ifdef CONTIKIMAC_CONF_INTER_PACKET_DEADLINE
#define INTER_PACKET_DEADLINE               CONTIKIMAC_CONF_INTER_PACKET_DEADLINE
#else
#define INTER_PACKET_DEADLINE               CLOCK_SECOND / 32
#endif

/* ContikiMAC performs periodic channel checks. Each channel check
   consists of two or more CCA checks. CCA_COUNT_MAX is the number of
   CCAs to be done for each periodic channel check. The default is
   two.*/
//#ifdef CONTIKIMAC_CONF_CCA_COUNT_MAX
//#define CCA_COUNT_MAX                      (CONTIKIMAC_CONF_CCA_COUNT_MAX)
//#else
//#define CCA_COUNT_MAX                      2
//#endif

/* Before starting a transmission, Contikimac checks the availability
   of the channel with CCA_COUNT_MAX_TX consecutive CCAs */
#ifdef CONTIKIMAC_CONF_CCA_COUNT_MAX_TX
#define CCA_COUNT_MAX_TX                   (CONTIKIMAC_CONF_CCA_COUNT_MAX_TX)
#else
#define CCA_COUNT_MAX_TX                   6
#endif

/* CCA_CHECK_TIME is the time it takes to perform a CCA check. */
/* Note this may be zero. AVRs have 7612 ticks/sec, but block until cca is done */
#ifdef CONTIKIMAC_CONF_CCA_CHECK_TIME
#define CCA_CHECK_TIME                     (CONTIKIMAC_CONF_CCA_CHECK_TIME)
#else
#define CCA_CHECK_TIME                     RTIMER_ARCH_SECOND / 8192
#endif

/* CCA_SLEEP_TIME is the time between two successive CCA checks. */
/* Add 1 when rtimer ticks are coarse */
#ifdef CONTIKIMAC_CONF_CCA_SLEEP_TIME
#define CCA_SLEEP_TIME CONTIKIMAC_CONF_CCA_SLEEP_TIME
#else
#if RTIMER_ARCH_SECOND > 8000
#define CCA_SLEEP_TIME                     RTIMER_ARCH_SECOND / 2000 + CCA_CHECK_TIME
//#define CCA_SLEEP_TIME                     RTIMER_ARCH_SECOND / 3225 - 2*CCA_CHECK_TIME
//#define CCA_SLEEP_TIME                     CCA_CHECK_TIME
#else
#define CCA_SLEEP_TIME                     (RTIMER_ARCH_SECOND / 2000) + 1 + CCA_CHECK_TIME
//#define CCA_SLEEP_TIME                     RTIMER_ARCH_SECOND / 3225 + 1 - 2*CCA_CHECK_TIME
//#define CCA_SLEEP_TIME                     CCA_CHECK_TIME
#endif /* RTIMER_ARCH_SECOND > 8000 */
#endif /* CONTIKIMAC_CONF_CCA_SLEEP_TIME */

/* CHECK_TIME is the total time it takes to perform CCA_COUNT_MAX
   CCAs. */
//#define CHECK_TIME                         (CCA_COUNT_MAX * (CCA_CHECK_TIME + CCA_SLEEP_TIME))
#define CHECK_TIME                         (1 * (CCA_CHECK_TIME + CCA_SLEEP_TIME))

/* CHECK_TIME_TX is the total time it takes to perform CCA_COUNT_MAX_TX
   CCAs. */
#define CHECK_TIME_TX                      (CCA_COUNT_MAX_TX * (CCA_CHECK_TIME + CCA_SLEEP_TIME))

/* LISTEN_TIME_AFTER_PACKET_DETECTED is the time that we keep checking
   for activity after a potential packet has been detected by a CCA
   check. */
#ifdef CONTIKIMAC_CONF_LISTEN_TIME_AFTER_PACKET_DETECTED
#define LISTEN_TIME_AFTER_PACKET_DETECTED  CONTIKIMAC_CONF_LISTEN_TIME_AFTER_PACKET_DETECTED
#else
#define LISTEN_TIME_AFTER_PACKET_DETECTED  RTIMER_ARCH_SECOND / 80
#endif

/* MAX_SILENCE_PERIODS is the maximum amount of periods (a period is
   CCA_CHECK_TIME + CCA_SLEEP_TIME) that we allow to be silent before
   we turn of the radio. */
#ifdef CONTIKIMAC_CONF_MAX_SILENCE_PERIODS
#define MAX_SILENCE_PERIODS                CONTIKIMAC_CONF_MAX_SILENCE_PERIODS
#else
#define MAX_SILENCE_PERIODS                5
#endif

/* MAX_NONACTIVITY_PERIODS is the maximum number of periods we allow
   the radio to be turned on without any packet being received, when
   WITH_FAST_SLEEP is enabled. */
#ifdef CONTIKIMAC_CONF_MAX_NONACTIVITY_PERIODS
#define MAX_NONACTIVITY_PERIODS            CONTIKIMAC_CONF_MAX_NONACTIVITY_PERIODS
#else
#define MAX_NONACTIVITY_PERIODS            10
#endif

#define NETSTACK_RDC_CHANNEL_CHECK_RANDOMNESS_FRACTION 10

/* BROADCAST_POLL_RATE is the rate (Hz) at which the broadcasting process checks for
   a timeout */
#define BROADCAST_POLL_RATE 100

/* GUARD_TIME is the time before the expected phase of a neighbor that
   a transmitted should begin transmitting packets. */
#ifdef CONTIKIMAC_CONF_GUARD_TIME
#define GUARD_TIME                         CONTIKIMAC_CONF_GUARD_TIME
#else
#define GUARD_TIME                         10 * CHECK_TIME + CHECK_TIME_TX
#endif

/* INTER_PACKET_INTERVAL is the interval between two successive packet transmissions */
#ifdef CONTIKIMAC_CONF_INTER_PACKET_INTERVAL
#define INTER_PACKET_INTERVAL              CONTIKIMAC_CONF_INTER_PACKET_INTERVAL
#else
#define INTER_PACKET_INTERVAL              RTIMER_ARCH_SECOND / 2500
#endif

#define MAX_BACKOFF                        RTIMER_ARCH_SECOND / 100
#define MIN_BACKOFF                        MAX_BACKOFF / 16

#define MAX_PROBE_ATTEMPTS                 5

//#define AFTER_PROBE_SENT_WAIT_TIME         RTIMER_ARCH_SECOND / 1200
#define AFTER_PROBE_SENT_WAIT_TIME         RTIMER_ARCH_SECOND / 600
//#define AFTER_PROBE_SENT_WAIT_TIME         RTIMER_ARCH_SECOND / 600 + MAX_BACKOFF

/* AFTER_ACK_DETECTED_WAIT_TIME is the time to wait after a potential
   ACK packet has been detected until we can read it out from the
   radio. */
#ifdef CONTIKIMAC_CONF_AFTER_ACK_DETECTED_WAIT_TIME
#define AFTER_ACK_DETECTED_WAIT_TIME      CONTIKIMAC_CONF_AFTER_ACK_DETECTED_WAIT_TIME
#else
#define AFTER_ACK_DETECTED_WAIT_TIME      RTIMER_ARCH_SECOND / 1500
#endif

#define PROBE_RECEIVE_DURATION            RTIMER_ARCH_SECOND / 1000
#define PACKET_RECEIVE_DURATION           RTIMER_ARCH_SECOND / 250

/* MAX_PHASE_STROBE_TIME is the time that we transmit repeated packets
   to a neighbor for which we have a phase lock. */
#ifdef CONTIKIMAC_CONF_MAX_PHASE_STROBE_TIME
#define MAX_PHASE_STROBE_TIME              CONTIKIMAC_CONF_MAX_PHASE_STROBE_TIME
#else
#define MAX_PHASE_STROBE_TIME              RTIMER_ARCH_SECOND / 60
#endif

#ifdef CONTIKIMAC_CONF_SEND_SW_ACK
#define CONTIKIMAC_SEND_SW_ACK CONTIKIMAC_CONF_SEND_SW_ACK
#else
#define CONTIKIMAC_SEND_SW_ACK 0
#endif

#define ACK_LEN 3
#define PROBE_LEN 0

#define BACKOFF_SLOT_LENGTH RTIMER_ARCH_SECOND / 100

#include <stdio.h>
static struct rtimer rt;
static struct ctimer probe_timer;
static struct pt pt;
static struct pt send_pt;

static volatile uint16_t probe_len = 0;
static linkaddr_t current_receiver_addr;
static volatile uint8_t current_seqno = 0;

static struct rdc_buf_list *curr_packet_list;
static mac_callback_t curr_callback;
static void *curr_ptr;

static volatile uint8_t contikimac_is_on = 0;
static volatile uint8_t contikimac_keep_radio_on = 0;

static volatile unsigned char we_are_sending = 0;
static volatile unsigned char we_are_listening = 0;
static volatile unsigned char we_are_broadcasting = 0;
static volatile unsigned char radio_is_on = 0;
static volatile unsigned char we_are_probing = 0;
static volatile unsigned char is_receiver_awake = 0;
static volatile unsigned char expecting_ack = 0;
static volatile unsigned char waiting_for_response = 0;

static volatile uint16_t probe_rate = 0;
static volatile uint16_t probe_interval = 0;
static volatile uint16_t max_probe_interval = 0;
static volatile uint16_t ctimer_max_probe_interval = 0;
static volatile uint16_t listen_for_probe_timeout = 0;
static volatile clock_time_t backoff_probe_timeout = 0;
static volatile rtimer_clock_t current_backoff_window = 0;

struct probe_packet {
  rtimer_clock_t backoff_window;
};

#include <lib/memb.h>
#include <lib/list.h>
struct addr_list_item {
  void * next;
  linkaddr_t addr;
};
#define MAX_NEIGHBORS 50
MEMB(addr_list_memb, struct addr_list_item, MAX_NEIGHBORS);
LIST(broadcast_addr_list);

#define DEBUG 1
#if DEBUG
#include <stdio.h>
#define PRINTF(...) printf(__VA_ARGS__)
#define PRINTDEBUG(...) printf(__VA_ARGS__)
#else
#define PRINTF(...)
#define PRINTDEBUG(...)
#endif

#if CONTIKIMAC_CONF_COMPOWER
static struct compower_activity current_packet;
#endif /* CONTIKIMAC_CONF_COMPOWER */

#if CONTIKIMAC_CONF_BROADCAST_RATE_LIMIT
static struct timer broadcast_rate_timer;
static int broadcast_rate_counter;
#endif /* CONTIKIMAC_CONF_BROADCAST_RATE_LIMIT */

static unsigned short duty_cycle(void);
/*---------------------------------------------------------------------------*/
static void
on(void)
{
  if(contikimac_is_on && radio_is_on == 0) {
    radio_is_on = 1;
    NETSTACK_RADIO.on();
  }
}
/*---------------------------------------------------------------------------*/
static void
off(void)
{
  if(contikimac_is_on && radio_is_on != 0 &&
     contikimac_keep_radio_on == 0) {
    radio_is_on = 0;
    NETSTACK_RADIO.off();
  }
}
/*---------------------------------------------------------------------------*/
static void powercycle_wrapper(struct rtimer *t, void *ptr);
static char powercycle(void *ptr);
/*---------------------------------------------------------------------------*/
static void
powercycle_turn_radio_off(void)
{
#if CONTIKIMAC_CONF_COMPOWER
  uint8_t was_on = radio_is_on;
#endif /* CONTIKIMAC_CONF_COMPOWER */
  if(!contikimac_is_on) {
    return;
  }
  if(we_are_sending == 0 && we_are_receiving_burst == 0 && we_are_listening == 0) {
    off();
#if CONTIKIMAC_CONF_COMPOWER
    if(was_on && !radio_is_on) {
      compower_accumulate(&compower_idle_activity);
    }
#endif /* CONTIKIMAC_CONF_COMPOWER */
  } else {
    PRINTF("lpprdc: not turning radio off\n");
  }
}
/*---------------------------------------------------------------------------*/
static void
powercycle_turn_radio_on(void)
{
  if(we_are_sending == 0 && we_are_receiving_burst == 0 && we_are_listening == 0) {
    on();
  }
}
/*---------------------------------------------------------------------------*/
static void
powercycle_wrapper(struct rtimer *t, void *ptr)
{
  if(waiting_for_response) {
    powercycle(ptr);
  }
}
/*---------------------------------------------------------------------------*/
static void
powercycle_ctimer_wrapper(void *ptr)
{
  powercycle(ptr);
}
/*---------------------------------------------------------------------------*/
/*
 * Send probes and listen for a response.
*/
static char
powercycle(void *ptr)
{

  PT_BEGIN(&pt);

  static struct probe_packet probe;
  static uint8_t probe_attempts = 0;
  static uint8_t channel_was_clear = 0;
  static uint8_t activity_seen = 0;
  static rtimer_clock_t wait_time = 0;
  static rtimer_clock_t time_high = 0;

  while(1) {
    static rtimer_clock_t wt;

    if(we_are_listening == 0 && we_are_sending == 0 && we_are_receiving_burst == 0 &&
       !(NETSTACK_RADIO.receiving_packet() || NETSTACK_RADIO.pending_packet())) {
      we_are_probing = 1;

      if(probe_attempts > 0) {
        wait_time = ((1 << probe_attempts) - 1) * BACKOFF_SLOT_LENGTH;
      } else {
        wait_time = 0;
      }
      probe.backoff_window = wait_time;
      packetbuf_clear();
      packetbuf_copyfrom(&probe, sizeof(struct probe_packet));
      packetbuf_set_addr(PACKETBUF_ADDR_RECEIVER, &linkaddr_null);
      packetbuf_set_addr(PACKETBUF_ADDR_SENDER, &linkaddr_node_addr);
      if(NETSTACK_FRAMER.create() < 0) {
        PRINTDEBUG("lpprdc: Failed to create probe packet.\n");
        we_are_probing = 0;
      } else if(NETSTACK_RADIO.prepare(packetbuf_hdrptr(), probe_len)) {
        PRINTF("lpprdc: radio locked while probing\n");
        powercycle_turn_radio_off();
        we_are_probing = 0;
      } else { 
        powercycle_turn_radio_on();
        if(NETSTACK_RADIO.transmit(probe_len) != RADIO_TX_OK) {
          powercycle_turn_radio_off();
          we_are_probing = 0;
        } else {
          probe_attempts++;
        }
      }

      /* Listen for response and time out */
      if(we_are_probing) {
        channel_was_clear = 0;
        activity_seen = 0;
        waiting_for_response = 1;
        time_high = 0;
        wait_time += PACKET_RECEIVE_DURATION;
        uint16_t yield_time = 0;

        PRINTF("wait time %d\n", wait_time);
        wt = RTIMER_NOW();
        while(waiting_for_response && RTIMER_CLOCK_LT(RTIMER_NOW(), wt + wait_time)) {
          yield_time = CCA_SLEEP_TIME;
          //Immediately after sending beacon,
          //channel_clear() = 1 (at least in Cooja). We should wait for it to
          //go to zero and then watch for it to come back up to 1.
          if(NETSTACK_RADIO.channel_clear()) {
            if(activity_seen){
              if(RTIMER_CLOCK_DIFF(RTIMER_NOW(), time_high) > 
                 PROBE_RECEIVE_DURATION) {
                if(!NETSTACK_RADIO.pending_packet()) {
                  break;
                } else {
                  yield_time = 2*AFTER_ACK_DETECTED_WAIT_TIME;
                }
              } else {
                activity_seen = 0;
              }
            }
            channel_was_clear = 1;
          } else if(channel_was_clear) {
            if(!activity_seen) {
              time_high = RTIMER_NOW();
              activity_seen = 1;
            }
          }
          rtimer_set(&rt, RTIMER_NOW() + yield_time, 1,
                     powercycle_wrapper, NULL);
          PT_YIELD(&pt);
        }

        if(!waiting_for_response) {
          /* A response was received. We let input handle burst reception, so
             here we should send another probe. We reset probe_attempts because
             of the successful contention resolution. */
          probe_attempts = 0;
          continue;
        } else if(activity_seen) {
          /* We detected collision. Send another probe. */
          //TODO: we should check long enough to be sure it's not a probe
          //or have input tell us?
          if(probe_attempts < MAX_PROBE_ATTEMPTS) {
            //TODO: This is simplistic. Should probably check long enough to
            //be sure we're not in the turnaround between probe & data or data & ack
            while(!NETSTACK_RADIO.channel_clear()) { }
            continue;
          } else {
            powercycle_turn_radio_off();
          }
        } else {
leds_blink();
          /* We timed out */
          powercycle_turn_radio_off();
        }
      }
    } else {
      PRINTF("lpprdc: skipping probe\n");
      PRINTF("listening %d, sending %d, rec burst %d\n", we_are_listening, we_are_sending, we_are_receiving_burst);
    }
    waiting_for_response = 0;
    we_are_probing = 0;
    int32_t rand = (int32_t)random_rand() - (RANDOM_RAND_MAX / 2);
    rand = rand / NETSTACK_RDC_CHANNEL_CHECK_RANDOMNESS_FRACTION * probe_interval / (RANDOM_RAND_MAX / 2);
    uint32_t probe_interval_rand = (uint32_t)probe_interval + rand;
    ctimer_set(&probe_timer, probe_interval_rand, powercycle_ctimer_wrapper, NULL);
    probe_attempts = 0;
    PT_YIELD(&pt);
  }

  PT_END(&pt);
}
/*---------------------------------------------------------------------------*/
static int
broadcast_rate_drop(void)
{
#if CONTIKIMAC_CONF_BROADCAST_RATE_LIMIT
  if(!timer_expired(&broadcast_rate_timer)) {
    broadcast_rate_counter++;
    if(broadcast_rate_counter < CONTIKIMAC_CONF_BROADCAST_RATE_LIMIT) {
      return 0;
    } else {
      return 1;
    }
  } else {
    timer_set(&broadcast_rate_timer, CLOCK_SECOND);
    broadcast_rate_counter = 0;
    return 0;
  }
#else /* CONTIKIMAC_CONF_BROADCAST_RATE_LIMIT */
  return 0;
#endif /* CONTIKIMAC_CONF_BROADCAST_RATE_LIMIT */
}
/*---------------------------------------------------------------------------*/
static char send_packet();
/* Timer callback triggered on timeout when listening for probe */
static void
listening_off(void *ptr)
{
  send_packet();
}
/*---------------------------------------------------------------------------*/
/* Timer callback triggered on timeout when waiting for backoff */
static void
backoff_timeout(struct rtimer *rt, void *ptr)
{
  if(!is_receiver_awake) {
    /* This means no more probes were heard - it's time to send. */
    send_packet();
  }
}
/*---------------------------------------------------------------------------*/
static char
send_packet()
{
  PT_BEGIN(&send_pt);

  static uint8_t got_packet_ack = 0;
  static uint8_t is_broadcast = 0;
  static uint8_t collisions = 0;
  static uint8_t retry = 0;
  static int transmit_len = 0;
  static int ret = 0;
  static uint8_t contikimac_was_on = 1;
  static struct rdc_buf_list *next;
  static struct ctimer ct;
  struct addr_list_item *item;
  int list_contains_addr = 0;
  static linkaddr_t receiver_addr;
  static uint8_t packet_pushed = 0;
  static clock_time_t broadcast_start_time = 0;

  /* Exit if RDC and radio were explicitly turned off */
  if(!contikimac_is_on && !contikimac_keep_radio_on) {
    PRINTF("lpprdc: radio is turned off\n");
    mac_call_sent_callback(curr_callback, curr_ptr, MAC_TX_ERR_FATAL, 1);
    return 0;
  }

  if(we_are_probing || we_are_receiving_burst) {
    PRINTF("lpprdc: collision receiving %d, pending %d\n",
           NETSTACK_RADIO.receiving_packet(), NETSTACK_RADIO.pending_packet());
    mac_call_sent_callback(curr_callback, curr_ptr, MAC_TX_COLLISION, 1);
    return 0;
  }

  we_are_listening = 1;

  do {

    collisions = 0;
    got_packet_ack = 0;

    if(!retry) {
    /* Send the packet once if channel clear - similar to RI-MAC's 
       "beacon on request" but skipping the beacons */
      packet_pushed = 0;

      queuebuf_to_packetbuf(curr_packet_list->buf);
      transmit_len = packetbuf_totlen();
      if(transmit_len == 0) {
        PRINTF("lpprdc: send_packet data len 0\n");
        mac_call_sent_callback(curr_callback, curr_ptr, MAC_TX_ERR_FATAL, 1);
        we_are_listening = 0;
        return 0;
      }
      current_seqno = packetbuf_attr(PACKETBUF_ATTR_MAC_SEQNO);

      if(packetbuf_holds_broadcast()) {
        is_broadcast = 1;
        we_are_broadcasting = 1;
        linkaddr_copy(&current_receiver_addr, &linkaddr_null);
        while(list_length(broadcast_addr_list) > 0) {
          item = list_pop(broadcast_addr_list);
          memb_free(&addr_list_memb, item);
        }
        broadcast_start_time = clock_time();
        PRINTDEBUG("lpprdc: send broadcast\n");

        if(broadcast_rate_drop()) {
          mac_call_sent_callback(curr_callback, curr_ptr, MAC_TX_COLLISION, 1);
          we_are_listening = 0;
          return 0;
        }
      } else {
        we_are_broadcasting = 0;
        is_broadcast = 0;
        if(!linkaddr_cmp(&current_receiver_addr, packetbuf_addr(PACKETBUF_ADDR_RECEIVER))) {
          is_receiver_awake = 0;
          linkaddr_copy(&current_receiver_addr, packetbuf_addr(PACKETBUF_ADDR_RECEIVER));
        }
#if NETSTACK_CONF_WITH_IPV6
        printf("lpprdc: send unicast to %02x%02x:%02x%02x:%02x%02x:%02x%02x\n",
               packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[0],
               packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[1],
               packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[2],
               packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[3],
               packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[4],
               packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[5],
               packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[6],
               packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[7]);
#else /* NETSTACK_CONF_WITH_IPV6 */
    /*PRINTDEBUG("lpprdc: send unicast to %u.%u\n",
               packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[0],
               packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[1]);*/
#endif /* NETSTACK_CONF_WITH_IPV6 */
      } //broadcast or unicast
    } //!retry

    /* This seems to fix the case where a beacon was received on
       accident and not processed. */
    if(NETSTACK_RADIO.pending_packet()) {
      NETSTACK_RADIO.read(NULL, 0);
    }

  /* Set contikimac_is_on to one to allow the on() and off() functions
     to control the radio. We restore the old value of
     contikimac_is_on when we are done. */
    contikimac_was_on = contikimac_is_on;
    contikimac_is_on = 1;

    next = list_item_next(curr_packet_list);

    on();
    
    do {
      if(packet_pushed && !is_receiver_awake) {
        /* We need to wait for a probe before doing anything. */
        on();
      
        if(is_broadcast) {
          ctimer_set(&ct, ctimer_max_probe_interval - (clock_time() - broadcast_start_time), listening_off, NULL);
        } else if(retry) {
          ctimer_set(&ct, (uint32_t)CLOCK_SECOND * current_backoff_window / RTIMER_ARCH_SECOND, listening_off, NULL);
        } else {
          ctimer_set(&ct, listen_for_probe_timeout, listening_off, NULL);
        }
        /* Yield until a beacon is heard (input) or timeout */
        PT_YIELD(&send_pt);
        ctimer_stop(&ct);
      }

      if(is_broadcast && packet_pushed) {
        if(!is_receiver_awake) {
          continue;
        }
        linkaddr_copy(&receiver_addr, packetbuf_addr(PACKETBUF_ADDR_SENDER));
        list_contains_addr = 0;
        item = list_head(broadcast_addr_list);
        while(item != NULL) {
          if(linkaddr_cmp(&receiver_addr, &item->addr)) {
            list_contains_addr = 1;
            break;
          }
          item = list_item_next(item);
        }
        if(list_contains_addr) {
          is_receiver_awake = 0;
          continue;
        }
      } else if(!is_broadcast && !is_receiver_awake && packet_pushed) {
        off();
        PRINTF("lpprdc: listen timed out\n");
        contikimac_is_on = contikimac_was_on;
        queuebuf_to_packetbuf(curr_packet_list->buf);
        mac_call_sent_callback(curr_callback, curr_ptr, MAC_TX_NOACK, 1);
        we_are_listening = 0;
        return 0;
      }

      /* If this is a retry, we should back off while listening for more probes */
      if(retry && current_backoff_window > 0) {
        PRINTF("lpprdc: backing off, backoff window %u\n", current_backoff_window);
        is_receiver_awake = 0;
        rtimer_set(&rt, RTIMER_NOW() + random_rand() % current_backoff_window, 1, backoff_timeout, NULL);
        PT_YIELD(&send_pt);
        /* If we got another probe, we should now follow backoff instructions for that probe */
        if(is_receiver_awake) {
          continue;
        }
      }

      we_are_sending = 1;
      queuebuf_to_packetbuf(curr_packet_list->buf);
#if RDC_CONF_HARDWARE_ACK
      off();
#endif

      if(NETSTACK_RADIO.prepare(packetbuf_hdrptr(), transmit_len)) {
        if(!packet_pushed++) {
          continue;
        }
        collisions++;
        break;
      }

      ret = NETSTACK_RADIO.transmit(transmit_len);

      is_receiver_awake = 0;
      if(is_broadcast) {
        if(packet_pushed++) {
          item = memb_alloc(&addr_list_memb);
          linkaddr_copy(&item->addr, &receiver_addr);
          list_add(broadcast_addr_list, item);
        }
        we_are_sending = 0;
        continue;
      }

#if RDC_CONF_HARDWARE_ACK
       /* For radios that block in the transmit routine and detect the
	  ACK in hardware */
      if(ret == RADIO_TX_OK) {
        if(!is_broadcast) {
          got_packet_ack = 1;
          packet_pushed++;
        }
      } else if (ret == RADIO_TX_NOACK) {
        PRINTF("lpprdc: no ack\n");
        ret = RADIO_TX_COLLISION;
      } else if (ret == RADIO_TX_COLLISION) {
        PRINTF("lpprdc: collisions while sending (from radio)\n");
        retry = 1;
      }
      wt = RTIMER_NOW();
      while(RTIMER_CLOCK_LT(RTIMER_NOW(), wt + INTER_PACKET_INTERVAL)) { }
#else /* RDC_CONF_HARDWARE_ACK */
      if(ret == RADIO_TX_OK) {
        ctimer_set(&ct, 2, listening_off, NULL);
        /* Wait for the ACK packet */
        expecting_ack = 1;
        PT_YIELD(&send_pt);
        ctimer_stop(&ct);
        if(!expecting_ack) {
          PRINTF("!\n");
          got_packet_ack = 1;
          retry = 0;
          packet_pushed++;
        } else {
          if(is_receiver_awake) {
            //PRINTF("lpprdc: backoff beacon received\n");
            retry = 1;
          } else {
            //TODO: If we didn't hear a probe while listening for an ACK, what does that mean?
            PRINTF("lpprdc: ack listen timed out\n");
          }
        }
      } else if(packet_pushed) {
        /* Unicast and radio didn't return OK... radio layer collision */
        retry = 1;
      }
#endif /* RDC_CONF_HARDWARE_ACK */
    } while (!packet_pushed++ || (is_broadcast && clock_time() < broadcast_start_time + ctimer_max_probe_interval));

    if(!retry) {
      off();
    }

#if CONTIKIMAC_CONF_COMPOWER
    /* Accumulate the power consumption for the packet transmission. */
    compower_accumulate(&current_packet);

    /* Convert the accumulated power consumption for the transmitted
       packet to packet attributes so that the higher levels can keep
       track of the amount of energy spent on transmitting the
       packet. */
    compower_attrconv(&current_packet);

    /* Clear the accumulated power consumption so that it is ready for
       the next packet. */
    compower_clear(&current_packet);
#endif /* CONTIKIMAC_CONF_COMPOWER */

    contikimac_is_on = contikimac_was_on;
    we_are_sending = 0;

    if(got_packet_ack) {
      //TODO: if we're in a burst, it'd be faster to wait to send callbacks
      //after we've sent all packets...
      queuebuf_to_packetbuf(curr_packet_list->buf);
      mac_call_sent_callback(curr_callback, curr_ptr, MAC_TX_OK, 1);
      if(next != NULL) {
        /* We're in a burst, no need to wake the receiver up again */
        is_receiver_awake = 1;
        curr_packet_list = next;
      }
    } else if(retry) {
      PRINTF("lpprdc: retrying\n");
      continue;
    } else {
      /* This means no ACK, but no probe either */
      queuebuf_to_packetbuf(curr_packet_list->buf);
      mac_call_sent_callback(curr_callback, curr_ptr, MAC_TX_NOACK, 1);
      break;
    }
  } while(retry || (next != NULL));

  is_receiver_awake = 0;
  we_are_listening = 0;
  retry = 0;

  PT_END(&send_pt);
}
/*---------------------------------------------------------------------------*/
static void
qsend_list(mac_callback_t sent, void *ptr, struct rdc_buf_list *buf_list)
{
  struct rdc_buf_list *curr;
  struct rdc_buf_list *next;

  if(buf_list == NULL) {
    return;
  }

  /* Do not send during reception of a burst */
  if(we_are_receiving_burst || we_are_listening) {
    printf("failed qsend\n");
    /* Prepare the packetbuf for callback */
    queuebuf_to_packetbuf(buf_list->buf);
    /* Return COLLISION so the MAC may try again later */
    mac_call_sent_callback(sent, ptr, MAC_TX_COLLISION, 1);
    return;
  }

  /* Create and secure frames in advance */
  curr = buf_list;
  do {
    next = list_item_next(curr);
    queuebuf_to_packetbuf(curr->buf);
    if(!packetbuf_attr(PACKETBUF_ATTR_IS_CREATED_AND_SECURED)) {
      /* create and secure this frame */
      if(next != NULL) {
        packetbuf_set_attr(PACKETBUF_ATTR_PENDING, 1);
      }
#if !NETSTACK_CONF_BRIDGE_MODE
      /* If NETSTACK_CONF_BRIDGE_MODE is set, assume PACKETBUF_ADDR_SENDER is already set. */
      packetbuf_set_addr(PACKETBUF_ADDR_SENDER, &linkaddr_node_addr);
#endif
      packetbuf_set_attr(PACKETBUF_ATTR_MAC_ACK, 1);
      if(NETSTACK_FRAMER.create() < 0) {
        PRINTF("lpprdc: framer failed\n");
        mac_call_sent_callback(sent, ptr, MAC_TX_ERR_FATAL, 1);
        return;
      }

      packetbuf_set_attr(PACKETBUF_ATTR_IS_CREATED_AND_SECURED, 1);
      queuebuf_update_from_packetbuf(curr->buf);
    }
    curr = next;
  } while(next != NULL);

  /* The receiver needs to be awoken before we send */
  //is_receiver_awake = 0;
  curr_packet_list = buf_list;
  curr_callback = sent;
  curr_ptr = ptr;
  send_packet();
}
/*---------------------------------------------------------------------------*/
static void
qsend_packet(mac_callback_t sent, void *ptr)
{
  static struct rdc_buf_list list;
  list.next = NULL;
  list.buf = queuebuf_new_from_packetbuf();
  list.ptr = NULL;
  qsend_list(sent, ptr, &list);
}
/*---------------------------------------------------------------------------*/
/* Timer callback triggered when receiving a burst, after having
   waited for a next packet for a too long time. Turns the radio off
   and leaves burst reception mode */
static void
recv_burst_off(void *ptr)
{
  we_are_receiving_burst = 0;
  if(we_are_probing) {
    powercycle(NULL);
  } else {
    off();
  }
}
/*---------------------------------------------------------------------------*/
static void
input_packet(void)
{
  static struct ctimer ct;
  int duplicate = 0;
  int is_broadcast = 0;

#if CONTIKIMAC_SEND_SW_ACK
  int original_datalen;
  uint8_t *original_dataptr;

  original_datalen = packetbuf_datalen();
  original_dataptr = packetbuf_dataptr();
#endif
  
  if(!we_are_receiving_burst && !we_are_probing && !we_are_listening) {
    off();
  }
  
  if(packetbuf_datalen() == ACK_LEN) {
    if(expecting_ack && 
       ((uint8_t *)packetbuf_dataptr())[ACK_LEN - 1] == current_seqno) {
      expecting_ack = 0;
      send_packet();
    }
    return;
  }

  if(packetbuf_totlen() > 0 && NETSTACK_FRAMER.parse() >= 0) {
    if(packetbuf_datalen() == sizeof(struct probe_packet)) {
      if(we_are_listening && (we_are_broadcasting || linkaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_SENDER), &current_receiver_addr))) {
        current_backoff_window = ((struct probe_packet *)(packetbuf_dataptr()))->backoff_window;
        is_receiver_awake = 1;
        send_packet();
      } else {
        //PRINTF("lpprdc: ignored beacon\n");
      }
      return;
    }

    is_broadcast = packetbuf_holds_broadcast();
    if(packetbuf_datalen() > 0 &&
       packetbuf_totlen() > 0 &&
       (linkaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_RECEIVER),
                     &linkaddr_node_addr) ||
        is_broadcast)) {
      /* This is a regular packet that is destined to us or to the
         broadcast address. */
      PRINTF("lpprdc: packet received, broadcast: %d\n", packetbuf_holds_broadcast());

      /* If FRAME_PENDING is set, we are receiving a packets in a burst */
      we_are_receiving_burst = packetbuf_attr(PACKETBUF_ATTR_PENDING);
      PRINTF("lpprdc: receiving burst %d\n", we_are_receiving_burst);
      if(we_are_receiving_burst) {
        on();
        /* Set a timer to turn the radio off in case we do not receive
	   a next packet */
        ctimer_set(&ct, INTER_PACKET_DEADLINE, recv_burst_off, NULL);
      } else {
        if(!(we_are_listening || we_are_probing)) {
          off();
        }
        ctimer_stop(&ct);
      }

#if RDC_WITH_DUPLICATE_DETECTION
      /* Check for duplicate packet. */
      duplicate = mac_sequence_is_duplicate();
      if(duplicate) {
        /* Drop the packet. */
        //PRINTF("lpprdc: Drop duplicate\n");
      } else {
        mac_sequence_register_seqno();
      }
#endif /* RDC_WITH_DUPLICATE_DETECTION */

#if CONTIKIMAC_CONF_COMPOWER
      /* Accumulate the power consumption for the packet reception. */
      compower_accumulate(&current_packet);
      /* Convert the accumulated power consumption for the received
         packet to packet attributes so that the higher levels can
         keep track of the amount of energy spent on receiving the
         packet. */
      compower_attrconv(&current_packet);

      /* Clear the accumulated power consumption so that it is ready
         for the next packet. */
      compower_clear(&current_packet);
#endif /* CONTIKIMAC_CONF_COMPOWER */

      //PRINTDEBUG("lpprdc: data (%u)\n", packetbuf_datalen());

#if CONTIKIMAC_SEND_SW_ACK
      {
        frame802154_t info154;
        frame802154_parse(original_dataptr, original_datalen, &info154);
        if(info154.fcf.frame_type == FRAME802154_DATAFRAME &&
            info154.fcf.ack_required != 0 &&
            linkaddr_cmp((linkaddr_t *)&info154.dest_addr,
                &linkaddr_node_addr)) {
          uint8_t ackdata[ACK_LEN] = {0, 0, 0};

          we_are_sending = 1;
          ackdata[0] = FRAME802154_ACKFRAME;
          ackdata[1] = 0;
          ackdata[2] = info154.seq;
          NETSTACK_RADIO.send(ackdata, ACK_LEN);
          we_are_sending = 0;
        }
      }
#endif /* CONTIKIMAC_SEND_SW_ACK */

      if(!duplicate) {
        NETSTACK_MAC.input();
      }
      if(we_are_probing && !we_are_receiving_burst) {
        PRINTF("lpprdc: keep probing!\n");
        waiting_for_response = 0;
        powercycle(NULL);
      }
      return;
    } else {
      PRINTDEBUG("lpprdc: data not for us\n");
      off();
    }
  } else {
    //PRINTF("lpprdc: failed to parse (%u)\n", packetbuf_totlen());
  }
}
/*---------------------------------------------------------------------------*/
static void
init(void)
{
  radio_value_t radio_tx_mode = 0;
  /*if(NETSTACK_RADIO.get_value(RADIO_PARAM_TX_MODE, &radio_tx_mode) != RADIO_RESULT_OK) {
    PRINTF("lpprdc: failed to get radio params, aborting\n");
    return;
  }
  radio_tx_mode &= ~RADIO_TX_MODE_SEND_ON_CCA;
  if(NETSTACK_RADIO.set_value(RADIO_PARAM_TX_MODE, radio_tx_mode) != RADIO_RESULT_OK) {
    PRINTF("lpprdc: failed to set radio params, aborting\n");
    return;
  }*/
  radio_is_on = 0;
  radio_value_t tx_power = 0;
  NETSTACK_RADIO.get_value(RADIO_PARAM_TXPOWER, &tx_power);
  PRINTF("radio tx power: %d\n", tx_power);

  struct probe_packet probe;
  probe.backoff_window = 0;
  packetbuf_clear();
      packetbuf_copyfrom(&probe, sizeof(struct probe_packet));
      packetbuf_set_addr(PACKETBUF_ADDR_RECEIVER, &linkaddr_null);
      packetbuf_set_addr(PACKETBUF_ADDR_SENDER, &linkaddr_node_addr);
      if(NETSTACK_FRAMER.create() < 0) {
        PRINTDEBUG("lpprdc: Failed to create probe packet.\n");
      }

      probe_len = packetbuf_totlen();

  memb_init(&addr_list_memb);

  probe_rate = NETSTACK_RDC_CHANNEL_CHECK_RATE;
  probe_interval = CLOCK_SECOND / probe_rate;
  ctimer_max_probe_interval = probe_interval + probe_interval / NETSTACK_RDC_CHANNEL_CHECK_RANDOMNESS_FRACTION;
  max_probe_interval = RTIMER_ARCH_SECOND / CLOCK_SECOND * ctimer_max_probe_interval;
  listen_for_probe_timeout = 3*ctimer_max_probe_interval;

  PT_INIT(&pt);
  PT_INIT(&send_pt);

  ctimer_set(&probe_timer, probe_interval, powercycle_ctimer_wrapper, NULL);

  contikimac_is_on = 1;
}
/*---------------------------------------------------------------------------*/
static int
turn_on(void)
{
  if(contikimac_is_on == 0) {
    contikimac_is_on = 1;
    contikimac_keep_radio_on = 0;
    ctimer_set(&probe_timer, probe_interval, powercycle_ctimer_wrapper, NULL);
  }
  return 1;
}
/*---------------------------------------------------------------------------*/
static int
turn_off(int keep_radio_on)
{
  contikimac_is_on = 0;
  contikimac_keep_radio_on = keep_radio_on;
  if(keep_radio_on) {
    radio_is_on = 1;
    return NETSTACK_RADIO.on();
  } else {
    radio_is_on = 0;
    return NETSTACK_RADIO.off();
  }
}
/*---------------------------------------------------------------------------*/
static unsigned short
duty_cycle(void)
{
  /* This is called by CSMA to set the backoff length */
  return 5;
  //return (1ul * CLOCK_SECOND / probe_rate);
}
/*---------------------------------------------------------------------------*/
const struct rdc_driver lpprdc_driver = {
  "LPP-RDC",
  init,
  qsend_packet,
  qsend_list,
  input_packet,
  turn_on,
  turn_off,
  duty_cycle,
};
/*---------------------------------------------------------------------------*/
uint16_t
lpprdc_debug_print(void)
{
  return 0;
}
/*---------------------------------------------------------------------------*/
