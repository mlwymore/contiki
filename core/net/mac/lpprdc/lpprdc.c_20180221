/*
 * Copyright (c) 2010, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of the Contiki operating system.
 *
 */

/**
 * \file
 *         Implementation of a low-power probing radio duty cycling protocol,
 *         based on contikimac.c.
 * \author
 *         Mat Wymore <mlwymore@gmail.com>
 */

#include "contiki-conf.h"
#include "dev/leds.h"
#include "dev/radio.h"
#include "dev/watchdog.h"
#include "lib/random.h"
#include "net/mac/mac-sequence.h"
#include "net/mac/lpprdc/lpprdc.h"
#include "net/mac/contikimac/contikimac-framer.h"
#include "net/netstack.h"
#include "net/rime/rime.h"
#include "sys/compower.h"
#include "sys/pt.h"
#include "sys/rtimer.h"


#include <string.h>

/* TX/RX cycles are synchronized with neighbor wake periods */
#ifdef CONTIKIMAC_CONF_WITH_PHASE_OPTIMIZATION
#define WITH_PHASE_OPTIMIZATION      CONTIKIMAC_CONF_WITH_PHASE_OPTIMIZATION
#else /* CONTIKIMAC_CONF_WITH_PHASE_OPTIMIZATION */
#define WITH_PHASE_OPTIMIZATION      0
#endif /* CONTIKIMAC_CONF_WITH_PHASE_OPTIMIZATION */
/* More aggressive radio sleeping when channel is busy with other traffic */
#ifndef WITH_FAST_SLEEP
#define WITH_FAST_SLEEP              1
#endif
/* Radio does CSMA and autobackoff */
#ifndef RDC_CONF_HARDWARE_CSMA
#define RDC_CONF_HARDWARE_CSMA       0
#endif
/* Radio returns TX_OK/TX_NOACK after autoack wait */
#ifndef RDC_CONF_HARDWARE_ACK
#define RDC_CONF_HARDWARE_ACK        0
#endif
/* MCU can sleep during radio off */
#ifndef RDC_CONF_MCU_SLEEP
#define RDC_CONF_MCU_SLEEP           0
#endif

#if NETSTACK_RDC_CHANNEL_CHECK_RATE >= 64
#undef WITH_PHASE_OPTIMIZATION
#define WITH_PHASE_OPTIMIZATION 0
#endif

/* CHANNEL_CHECK_RATE is enforced to be a power of two.
 * If RTIMER_ARCH_SECOND is not also a power of two, there will be an inexact
 * number of channel checks per second due to the truncation of CYCLE_TIME.
 * This will degrade the effectiveness of phase optimization with neighbors that
 * do not have the same truncation error.
 * Define SYNC_CYCLE_STARTS to ensure an integral number of checks per second.
 */
#if RTIMER_ARCH_SECOND & (RTIMER_ARCH_SECOND - 1)
#define SYNC_CYCLE_STARTS                    1
#endif

/* Are we currently receiving a burst? */
static int we_are_receiving_burst = 0;

/* INTER_PACKET_DEADLINE is the maximum time a receiver waits for the
   next packet of a burst when FRAME_PENDING is set. */
#ifdef CONTIKIMAC_CONF_INTER_PACKET_DEADLINE
#define INTER_PACKET_DEADLINE               CONTIKIMAC_CONF_INTER_PACKET_DEADLINE
#else
#define INTER_PACKET_DEADLINE               CLOCK_SECOND / 32
#endif

/* ContikiMAC performs periodic channel checks. Each channel check
   consists of two or more CCA checks. CCA_COUNT_MAX is the number of
   CCAs to be done for each periodic channel check. The default is
   two.*/
//#ifdef CONTIKIMAC_CONF_CCA_COUNT_MAX
//#define CCA_COUNT_MAX                      (CONTIKIMAC_CONF_CCA_COUNT_MAX)
//#else
//#define CCA_COUNT_MAX                      2
//#endif

/* Before starting a transmission, Contikimac checks the availability
   of the channel with CCA_COUNT_MAX_TX consecutive CCAs */
#ifdef CONTIKIMAC_CONF_CCA_COUNT_MAX_TX
#define CCA_COUNT_MAX_TX                   (CONTIKIMAC_CONF_CCA_COUNT_MAX_TX)
#else
#define CCA_COUNT_MAX_TX                   6
#endif

/* CCA_CHECK_TIME is the time it takes to perform a CCA check. */
/* Note this may be zero. AVRs have 7612 ticks/sec, but block until cca is done */
#ifdef CONTIKIMAC_CONF_CCA_CHECK_TIME
#define CCA_CHECK_TIME                     (CONTIKIMAC_CONF_CCA_CHECK_TIME)
#else
#define CCA_CHECK_TIME                     RTIMER_ARCH_SECOND / 8192
#endif

/* CCA_SLEEP_TIME is the time between two successive CCA checks. */
/* Add 1 when rtimer ticks are coarse */
#ifdef CONTIKIMAC_CONF_CCA_SLEEP_TIME
#define CCA_SLEEP_TIME CONTIKIMAC_CONF_CCA_SLEEP_TIME
#else
#if RTIMER_ARCH_SECOND > 8000
#define CCA_SLEEP_TIME                     RTIMER_ARCH_SECOND / 2000 + CCA_CHECK_TIME
//#define CCA_SLEEP_TIME                     RTIMER_ARCH_SECOND / 3225 - 2*CCA_CHECK_TIME
//#define CCA_SLEEP_TIME                     CCA_CHECK_TIME
#else
#define CCA_SLEEP_TIME                     (RTIMER_ARCH_SECOND / 2000) + 1 + CCA_CHECK_TIME
//#define CCA_SLEEP_TIME                     RTIMER_ARCH_SECOND / 3225 + 1 - 2*CCA_CHECK_TIME
//#define CCA_SLEEP_TIME                     CCA_CHECK_TIME
#endif /* RTIMER_ARCH_SECOND > 8000 */
#endif /* CONTIKIMAC_CONF_CCA_SLEEP_TIME */

/* CHECK_TIME is the total time it takes to perform CCA_COUNT_MAX
   CCAs. */
//#define CHECK_TIME                         (CCA_COUNT_MAX * (CCA_CHECK_TIME + CCA_SLEEP_TIME))
#define CHECK_TIME                         (1 * (CCA_CHECK_TIME + CCA_SLEEP_TIME))

/* CHECK_TIME_TX is the total time it takes to perform CCA_COUNT_MAX_TX
   CCAs. */
#define CHECK_TIME_TX                      (CCA_COUNT_MAX_TX * (CCA_CHECK_TIME + CCA_SLEEP_TIME))

/* LISTEN_TIME_AFTER_PACKET_DETECTED is the time that we keep checking
   for activity after a potential packet has been detected by a CCA
   check. */
#ifdef CONTIKIMAC_CONF_LISTEN_TIME_AFTER_PACKET_DETECTED
#define LISTEN_TIME_AFTER_PACKET_DETECTED  CONTIKIMAC_CONF_LISTEN_TIME_AFTER_PACKET_DETECTED
#else
#define LISTEN_TIME_AFTER_PACKET_DETECTED  RTIMER_ARCH_SECOND / 80
#endif

/* MAX_SILENCE_PERIODS is the maximum amount of periods (a period is
   CCA_CHECK_TIME + CCA_SLEEP_TIME) that we allow to be silent before
   we turn of the radio. */
#ifdef CONTIKIMAC_CONF_MAX_SILENCE_PERIODS
#define MAX_SILENCE_PERIODS                CONTIKIMAC_CONF_MAX_SILENCE_PERIODS
#else
#define MAX_SILENCE_PERIODS                5
#endif

/* MAX_NONACTIVITY_PERIODS is the maximum number of periods we allow
   the radio to be turned on without any packet being received, when
   WITH_FAST_SLEEP is enabled. */
#ifdef CONTIKIMAC_CONF_MAX_NONACTIVITY_PERIODS
#define MAX_NONACTIVITY_PERIODS            CONTIKIMAC_CONF_MAX_NONACTIVITY_PERIODS
#else
#define MAX_NONACTIVITY_PERIODS            10
#endif

#define NETSTACK_RDC_CHANNEL_CHECK_RANDOMNESS_FRACTION 10

/* BROADCAST_POLL_RATE is the rate (Hz) at which the broadcasting process checks for
   a timeout */
#define BROADCAST_POLL_RATE 100

/* GUARD_TIME is the time before the expected phase of a neighbor that
   a transmitted should begin transmitting packets. */
#ifdef CONTIKIMAC_CONF_GUARD_TIME
#define GUARD_TIME                         CONTIKIMAC_CONF_GUARD_TIME
#else
#define GUARD_TIME                         10 * CHECK_TIME + CHECK_TIME_TX
#endif

/* INTER_PACKET_INTERVAL is the interval between two successive packet transmissions */
#ifdef CONTIKIMAC_CONF_INTER_PACKET_INTERVAL
#define INTER_PACKET_INTERVAL              CONTIKIMAC_CONF_INTER_PACKET_INTERVAL
#else
#define INTER_PACKET_INTERVAL              RTIMER_ARCH_SECOND / 2500
#endif

#define MAX_BACKOFF                        RTIMER_ARCH_SECOND / 100
#define MIN_BACKOFF                        MAX_BACKOFF / 16

//#define AFTER_PROBE_SENT_WAIT_TIME         RTIMER_ARCH_SECOND / 1200
#define AFTER_PROBE_SENT_WAIT_TIME         RTIMER_ARCH_SECOND / 600
//#define AFTER_PROBE_SENT_WAIT_TIME         RTIMER_ARCH_SECOND / 600 + MAX_BACKOFF

/* AFTER_ACK_DETECTED_WAIT_TIME is the time to wait after a potential
   ACK packet has been detected until we can read it out from the
   radio. */
#ifdef CONTIKIMAC_CONF_AFTER_ACK_DETECTED_WAIT_TIME
#define AFTER_ACK_DETECTED_WAIT_TIME      CONTIKIMAC_CONF_AFTER_ACK_DETECTED_WAIT_TIME
#else
#define AFTER_ACK_DETECTED_WAIT_TIME      RTIMER_ARCH_SECOND / 1500
#endif

/* MAX_PHASE_STROBE_TIME is the time that we transmit repeated packets
   to a neighbor for which we have a phase lock. */
#ifdef CONTIKIMAC_CONF_MAX_PHASE_STROBE_TIME
#define MAX_PHASE_STROBE_TIME              CONTIKIMAC_CONF_MAX_PHASE_STROBE_TIME
#else
#define MAX_PHASE_STROBE_TIME              RTIMER_ARCH_SECOND / 60
#endif

#ifdef CONTIKIMAC_CONF_SEND_SW_ACK
#define CONTIKIMAC_SEND_SW_ACK CONTIKIMAC_CONF_SEND_SW_ACK
#else
#define CONTIKIMAC_SEND_SW_ACK 0
#endif

#define ACK_LEN 3
#define PROBE_LEN 0

#include <stdio.h>
static struct rtimer rt;
static struct ctimer probe_timer;
static struct pt pt;
static struct pt send_pt;

static uint32_t probebuf_aligned[(PACKETBUF_SIZE + 3) / 4];
static uint8_t *probebuf = (uint8_t *)probebuf_aligned;
static uint16_t probe_len = 0;
static linkaddr_t current_receiver_addr;

static struct rdc_buf_list *curr_packet_list;
static mac_callback_t curr_callback;
static void *curr_ptr;

static volatile uint8_t contikimac_is_on = 0;
static volatile uint8_t contikimac_keep_radio_on = 0;

static volatile unsigned char we_are_sending = 0;
static volatile unsigned char we_are_listening = 0;
static volatile unsigned char we_are_broadcasting = 0;
static volatile unsigned char radio_is_on = 0;
static volatile unsigned char we_are_probing = 0;
static volatile unsigned char is_receiver_awake = 0;

static volatile uint16_t probe_rate = 0;
static volatile uint16_t probe_interval = 0;
static volatile uint16_t max_probe_interval = 0;
static volatile uint16_t ctimer_max_probe_interval = 0;
static volatile uint16_t listen_for_probe_timeout = 0;

struct probe_packet {
  uint16_t backoff_window;
};

#include <lib/memb.h>
#include <lib/list.h>
struct addr_list_item {
  void * next;
  linkaddr_t addr;
};
#define MAX_NEIGHBORS 50
MEMB(addr_list_memb, struct addr_list_item, MAX_NEIGHBORS);
LIST(broadcast_addr_list);

#define DEBUG 0
#if DEBUG
#include <stdio.h>
#define PRINTF(...) printf(__VA_ARGS__)
#define PRINTDEBUG(...) printf(__VA_ARGS__)
#else
#define PRINTF(...)
#define PRINTDEBUG(...)
#endif

#if CONTIKIMAC_CONF_COMPOWER
static struct compower_activity current_packet;
#endif /* CONTIKIMAC_CONF_COMPOWER */

#if WITH_PHASE_OPTIMIZATION

#include "net/mac/phase.h"

#endif /* WITH_PHASE_OPTIMIZATION */

#if CONTIKIMAC_CONF_BROADCAST_RATE_LIMIT
static struct timer broadcast_rate_timer;
static int broadcast_rate_counter;
#endif /* CONTIKIMAC_CONF_BROADCAST_RATE_LIMIT */

/*---------------------------------------------------------------------------*/
static void
on(void)
{
  if(contikimac_is_on && radio_is_on == 0) {
    radio_is_on = 1;
    NETSTACK_RADIO.on();
  }
}
/*---------------------------------------------------------------------------*/
static void
off(void)
{
  if(contikimac_is_on && radio_is_on != 0 &&
     contikimac_keep_radio_on == 0) {
    radio_is_on = 0;
    NETSTACK_RADIO.off();
  }
}
/*---------------------------------------------------------------------------*/
static void powercycle_wrapper(struct rtimer *t, void *ptr);
static void powercycle(void *ptr);
/*---------------------------------------------------------------------------*/
static volatile rtimer_clock_t cycle_start;
#if SYNC_CYCLE_STARTS
static volatile rtimer_clock_t sync_cycle_start;
static volatile uint8_t sync_cycle_phase;
#endif
/*---------------------------------------------------------------------------*/
static void
schedule_powercycle(struct rtimer *t, rtimer_clock_t time)
{
  int r;
  rtimer_clock_t now;

  //if(contikimac_is_on) {

    time += RTIMER_TIME(t);
    now = RTIMER_NOW();
    if(RTIMER_CLOCK_LT(time, now + RTIMER_GUARD_TIME)) {
      time = now + RTIMER_GUARD_TIME;
    }

    r = rtimer_set(t, time, 1, powercycle_wrapper, NULL);

    if(r != RTIMER_OK) {
      PRINTF("schedule_powercycle: could not set rtimer\n");
    }
  //}
}
/*---------------------------------------------------------------------------*/
static void
schedule_powercycle_fixed(struct rtimer *t, rtimer_clock_t fixed_time)
{
  int r;
  rtimer_clock_t now;

  //if(contikimac_is_on) {

    now = RTIMER_NOW();
    if(RTIMER_CLOCK_LT(fixed_time, now + RTIMER_GUARD_TIME)) {
      fixed_time = now + RTIMER_GUARD_TIME;
    }

    r = rtimer_set(t, fixed_time, 1, powercycle_wrapper, NULL);
    if(r != RTIMER_OK) {
      PRINTF("schedule_powercycle: could not set rtimer\n");
    }
  //}
}
/*---------------------------------------------------------------------------*/
static void
powercycle_turn_radio_off(void)
{
#if CONTIKIMAC_CONF_COMPOWER
  uint8_t was_on = radio_is_on;
#endif /* CONTIKIMAC_CONF_COMPOWER */
  if(!contikimac_is_on) {
    return;
  }
  if(we_are_sending == 0 && we_are_receiving_burst == 0 && we_are_listening == 0) {
    off();
#if CONTIKIMAC_CONF_COMPOWER
    if(was_on && !radio_is_on) {
      compower_accumulate(&compower_idle_activity);
    }
#endif /* CONTIKIMAC_CONF_COMPOWER */
  } else {
    //PRINTF("!\n");
    //PRINTF("lpprdc: Did not turn radio off after probe, we_are_sending: %d, we_are_receiving_burst: %d, we_are_listening: %d\n", we_are_sending, we_are_receiving_burst, we_are_listening);
  }
}
/*---------------------------------------------------------------------------*/
static void
powercycle_turn_radio_on(void)
{
  if(we_are_sending == 0 && we_are_receiving_burst == 0 && we_are_listening == 0) {
    on();
  } /*else {
    PRINTF("lpprdc: did not turn radio on, we_are_sending %d, we_are_receiving_burst %d, we_are_listening %d\n", we_are_sending, we_are_receiving_burst, we_are_listening);
  }*/
}
/*---------------------------------------------------------------------------*/
static void
powercycle_wrapper(struct rtimer *t, void *ptr)
{
  powercycle(ptr);
}
/*---------------------------------------------------------------------------*/
static void
advance_cycle_start(void)
{
  #if !WITH_PHASE_OPTIMIZATION
  int32_t rand;
  #endif
  #if SYNC_CYCLE_STARTS

  /* Compute cycle start when RTIMER_ARCH_SECOND is not a multiple
  of CHANNEL_CHECK_RATE */
  if(sync_cycle_phase++ == probe_rate) {
    sync_cycle_phase = 0;
    sync_cycle_start += RTIMER_ARCH_SECOND;
    cycle_start = sync_cycle_start;
  } else if( (RTIMER_ARCH_SECOND * probe_rate) > 65535) {
    uint32_t phase_time = sync_cycle_phase*RTIMER_ARCH_SECOND;

    cycle_start = sync_cycle_start + phase_time/probe_rate;
  } else {
    unsigned phase_time = sync_cycle_phase*RTIMER_ARCH_SECOND;

    cycle_start = sync_cycle_start + phase_time/probe_rate;
  }
  #endif
  /* We randomize probing times by a small amount to prevent repeated overlap,
     which can also interfere with sending routines. */
  //TODO: figure out a solution when phase optimization is being used
  #if !WITH_PHASE_OPTIMIZATION
  rand = (int32_t)random_rand() - (RANDOM_RAND_MAX / 2);
  cycle_start += rand*((RTIMER_ARCH_SECOND / probe_rate) / NETSTACK_RDC_CHANNEL_CHECK_RANDOMNESS_FRACTION)/(RANDOM_RAND_MAX / 2);
  #endif

  cycle_start += probe_interval;
}
/*---------------------------------------------------------------------------*/
/*
 * Instead of two CCAs, send a probe.
*/
//static char
//powercycle(struct rtimer *t, void *ptr)
static void
powercycle(void *ptr)
{

  PT_BEGIN(&pt);

#if SYNC_CYCLE_STARTS
  sync_cycle_start = RTIMER_NOW();
#else
  cycle_start = RTIMER_NOW();
#endif

  while(1) {
    rtimer_clock_t wt;

    if(we_are_listening == 0 && we_are_sending == 0 && we_are_receiving_burst == 0 &&
       !(NETSTACK_RADIO.receiving_packet() || NETSTACK_RADIO.pending_packet())) {
      we_are_probing = 1;

      if(NETSTACK_RADIO.prepare(probebuf, probe_len)) {
        PRINTF("lpprdc: radio locked while probing\n");
        powercycle_turn_radio_off();
        we_are_probing = 0;
      } else {
        
      powercycle_turn_radio_on();
      /*  Send a probe if channel is clear (we turned off CCA before transmit) */
      //if(NETSTACK_RADIO.channel_clear()) {
      if(NETSTACK_RADIO.transmit(probe_len) != RADIO_TX_OK) {
        powercycle_turn_radio_off();
        we_are_probing = 0;
      }
      }
      //} else {
      //  powercycle_turn_radio_off();
      //  we_are_probing = 0;
     // }

      /* Listen for response and time out */
      if(we_are_probing) {
        wt = RTIMER_NOW();
        int activity_seen = 0;
        while(RTIMER_CLOCK_LT(RTIMER_NOW(), wt + AFTER_PROBE_SENT_WAIT_TIME) && radio_is_on) {
          //PRINTF("%d\n", NETSTACK_RADIO.channel_clear());
          if(NETSTACK_RADIO.receiving_packet() || NETSTACK_RADIO.pending_packet()) {
            activity_seen = 1;
            break;
          }
        }
        if(radio_is_on && !activity_seen) {

          powercycle_turn_radio_off();
        } else {
          leds_blink();
        }
        we_are_probing = 0;
      }
    } else {
      //PRINTF("lpprdc: skipping probe\n");
      //PRINTF("we_are_probing: %d, receiving: %d, pending %d\n", we_are_probing, NETSTACK_RADIO.receiving_packet(), NETSTACK_RADIO.pending_packet());
      //NETSTACK_RADIO.read(0, NULL);
    }
    int32_t rand = (int32_t)random_rand() - (RANDOM_RAND_MAX / 2);
    rand = rand / NETSTACK_RDC_CHANNEL_CHECK_RANDOMNESS_FRACTION * probe_interval / (RANDOM_RAND_MAX / 2);
    uint32_t probe_interval_rand = (uint32_t)probe_interval + rand;
    ctimer_set(&probe_timer, probe_interval_rand, powercycle, NULL);
    PT_YIELD(&pt);
  }

  PT_END(&pt);
}
/*---------------------------------------------------------------------------*/
static int
broadcast_rate_drop(void)
{
#if CONTIKIMAC_CONF_BROADCAST_RATE_LIMIT
  if(!timer_expired(&broadcast_rate_timer)) {
    broadcast_rate_counter++;
    if(broadcast_rate_counter < CONTIKIMAC_CONF_BROADCAST_RATE_LIMIT) {
      return 0;
    } else {
      return 1;
    }
  } else {
    timer_set(&broadcast_rate_timer, CLOCK_SECOND);
    broadcast_rate_counter = 0;
    return 0;
  }
#else /* CONTIKIMAC_CONF_BROADCAST_RATE_LIMIT */
  return 0;
#endif /* CONTIKIMAC_CONF_BROADCAST_RATE_LIMIT */
}
/*---------------------------------------------------------------------------*/
static char send_packet();
/* Timer callback triggered on timeout when listening for probe */
static void
listening_off(void *ptr)
{
  send_packet();
}
/*---------------------------------------------------------------------------*/
static char
send_packet()
{
  PT_BEGIN(&send_pt);
#if WITH_PHASE_OPTIMIZATION
  static rtimer_clock_t encounter_time = 0;
#endif
  static uint8_t got_packet_ack = 0;
  static uint8_t is_broadcast = 0;
  static uint8_t collisions = 0;
  static int transmit_len = 0;
  static int ret = 0;
  static uint8_t contikimac_was_on = 1;
#if !RDC_CONF_HARDWARE_ACK
  static int len = 0;
  static uint8_t seqno = 0;
#endif
  static rtimer_clock_t wt = 0;
  static rtimer_clock_t bt = 0;
  static struct rdc_buf_list *next;
  static uint8_t pending = 0;
  static struct ctimer ct;
  struct addr_list_item *item;
  int list_contains_addr = 0;
  static linkaddr_t receiver_addr;
  static uint8_t packet_pushed = 0;

  /* Exit if RDC and radio were explicitly turned off */
  if(!contikimac_is_on && !contikimac_keep_radio_on) {
    PRINTF("lpprdc: radio is turned off\n");
    mac_call_sent_callback(curr_callback, curr_ptr, MAC_TX_ERR_FATAL, 1);
    return 0;
  }

  we_are_listening = 1;

  do {

    collisions = 0;
    got_packet_ack = 0;
    queuebuf_to_packetbuf(curr_packet_list->buf);
    transmit_len = packetbuf_totlen();

    if(packetbuf_holds_broadcast()) {
      is_broadcast = 1;
      we_are_broadcasting = 1;
      linkaddr_copy(&current_receiver_addr, &linkaddr_null);
      while(list_length(broadcast_addr_list) > 0) {
        item = list_pop(broadcast_addr_list);
        memb_free(&addr_list_memb, item);
      }
      bt = RTIMER_NOW();
      //PRINTDEBUG("lpprdc: send broadcast\n");

      if(broadcast_rate_drop()) {
        mac_call_sent_callback(curr_callback, curr_ptr, MAC_TX_COLLISION, 1);
      }
    } else {
      we_are_broadcasting = 0;
      is_broadcast = 0;
      linkaddr_copy(&current_receiver_addr, packetbuf_addr(PACKETBUF_ADDR_RECEIVER));
#if NETSTACK_CONF_WITH_IPV6
      printf("lpprdc: send unicast to %02x%02x:%02x%02x:%02x%02x:%02x%02x\n",
               packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[0],
               packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[1],
               packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[2],
               packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[3],
               packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[4],
               packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[5],
               packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[6],
               packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[7]);
#else /* NETSTACK_CONF_WITH_IPV6 */
    /*PRINTDEBUG("lpprdc: send unicast to %u.%u\n",
               packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[0],
               packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[1]);*/
#endif /* NETSTACK_CONF_WITH_IPV6 */
    }

    /* Phase opt probably doesn't work */
#if WITH_PHASE_OPTIMIZATION
    if(!is_broadcast && !is_receiver_awake) {

      ret = phase_wait(packetbuf_addr(PACKETBUF_ADDR_RECEIVER),
                     probe_interval, GUARD_TIME,
                     curr_callback, curr_ptr, curr_packet_list);
      if(ret == PHASE_DEFERRED) {
        mac_call_sent_callback(curr_callback, curr_ptr, MAC_TX_DEFERRED, 1);
        return;
      }
      if(ret != PHASE_UNKNOWN) {
        is_known_receiver = 1;
      }
    }
#endif /* WITH_PHASE_OPTIMIZATION */

  /* If we have a pending packet in the radio, we should not send now,
     because we will trash the received packet. Instead, we signal
     that we have a collision, which lets the packet be received. This
     packet will be retransmitted later by the MAC protocol
     instread. */
    if(we_are_probing || we_are_receiving_burst) {
      PRINTF("lpprdc: collision receiving %d, pending %d\n",
           NETSTACK_RADIO.receiving_packet(),                  NETSTACK_RADIO.pending_packet());
      mac_call_sent_callback(curr_callback, curr_ptr, MAC_TX_COLLISION, 1);
      break;
    }

    /* This seems to fix the case where a beacon was received on
       accident and not processed. */
    if(NETSTACK_RADIO.pending_packet()) {
      NETSTACK_RADIO.read(NULL, 0);
    }

  /* Switch off the radio to ensure that we didn't start sending while
     the radio was doing a channel check. */
  //off();

  /* Set contikimac_is_on to one to allow the on() and off() functions
     to control the radio. We restore the old value of
     contikimac_is_on when we are done. */
    contikimac_was_on = contikimac_is_on;
    contikimac_is_on = 1;

#if !RDC_CONF_HARDWARE_ACK
    seqno = packetbuf_attr(PACKETBUF_ATTR_MAC_SEQNO);
#endif

    next = list_item_next(curr_packet_list);

    /* Send the packet once if channel clear - similar to RI-MAC's 
       "beacon on request" but skipping the beacons */
    packet_pushed = 0;
    on();
    
    do {
    if(packet_pushed && (!is_receiver_awake || is_broadcast)) {
      //we_are_listening = 1;
      on();
      
      if(is_broadcast) {
        ctimer_set(&ct, CLOCK_SECOND / BROADCAST_POLL_RATE, listening_off, NULL);
      } else {
        ctimer_set(&ct, listen_for_probe_timeout, listening_off, NULL);
      }
      /* Yield until a beacon is heard (input) or timeout */
      PT_YIELD(&send_pt);
      ctimer_stop(&ct);

      //we_are_listening = 0;      
    }

    if(is_broadcast && packet_pushed) {
      if(!is_receiver_awake) {
        continue;
      }
      linkaddr_copy(&receiver_addr, packetbuf_addr(PACKETBUF_ADDR_SENDER));
      list_contains_addr = 0;
      item = list_head(broadcast_addr_list);
      while(item != NULL) {
        if(linkaddr_cmp(&receiver_addr, &item->addr)) {
          list_contains_addr = 1;
          break;
        }
        item = list_item_next(item);
      }
      if(list_contains_addr) {
        is_receiver_awake = 0;
        continue;
      } else {

      }
    } else if(!is_broadcast && !is_receiver_awake && packet_pushed) {
      off();
      PRINTF("lpprdc: listen timed out\n");
      contikimac_is_on = contikimac_was_on;
      queuebuf_to_packetbuf(curr_packet_list->buf);
      mac_call_sent_callback(curr_callback, curr_ptr, MAC_TX_NOACK, 1);
      break;
    }

    /*rtimer_clock_t backoff = (uint32_t)MAX_BACKOFF * random_rand() / RANDOM_RAND_MAX;
    wt = RTIMER_NOW();
    while(RTIMER_CLOCK_LT(RTIMER_NOW(), wt + backoff)) { }
    if(NETSTACK_RADIO.receiving_packet() || NETSTACK_RADIO.pending_packet() || !NETSTACK_RADIO.channel_clear()) {
      is_receiver_awake = 0;
      if(is_broadcast) {
        continue;
      } else {
        queuebuf_to_packetbuf(curr_packet_list->buf);
        mac_call_sent_callback(curr_callback, curr_ptr, MAC_TX_COLLISION, 1);
        break;
      }
    }*/
          
    we_are_sending = 1;

    queuebuf_to_packetbuf(curr_packet_list->buf);
#if RDC_CONF_HARDWARE_ACK
    off();
#endif
    //transmit_len = packetbuf_totlen();
    if(transmit_len == 0) {
      PRINTF("lpprdc: send_packet data len 0\n");
      //queuebuf_to_packetbuf(curr_packet_list->buf);
      mac_call_sent_callback(curr_callback, curr_ptr, MAC_TX_ERR_FATAL, 1);
      break;
    }

    if(NETSTACK_RADIO.prepare(packetbuf_hdrptr(), transmit_len)) {
      if(!packet_pushed++) {
        continue;
      }
      //queuebuf_to_packetbuf(curr_packet_list->buf);
      mac_call_sent_callback(curr_callback, curr_ptr, MAC_TX_COLLISION, 1);
      break;
    }
    /* check channel clear first? */
    //if(NETSTACK_RADIO.channel_clear()) {
#if RDC_CONF_HARDWARE_ACK
    ret = NETSTACK_RADIO.transmit(transmit_len);
#else
    NETSTACK_RADIO.transmit(transmit_len);
#endif

    pending = packetbuf_attr(PACKETBUF_ATTR_PENDING);
    //PRINTF("pending: %d\n", pending);

#if WITH_PHASE_OPTIMIZATION
    rtimer_clock_t txtime = RTIMER_NOW();
#endif

    if(is_broadcast) {
      if(packet_pushed++) {
        item = memb_alloc(&addr_list_memb);
        linkaddr_copy(&item->addr, &receiver_addr);
        list_add(broadcast_addr_list, item);
      }
      is_receiver_awake = 0;
      we_are_sending = 0;
      continue;
    }

#if RDC_CONF_HARDWARE_ACK
     /* For radios that block in the transmit routine and detect the
	ACK in hardware */
    if(ret == RADIO_TX_OK) {
      if(!is_broadcast) {
        got_packet_ack = 1;
        packet_pushed++;
#if WITH_PHASE_OPTIMIZATION
        encounter_time = txtime;
#endif
      }
    } else if (ret == RADIO_TX_NOACK) {
      PRINTF("lpprdc: no ack\n");
    } else if (ret == RADIO_TX_COLLISION) {
      PRINTF("lpprdc: collisions while sending (from radio)\n");
      collisions++;
    }
    wt = RTIMER_NOW();
    while(RTIMER_CLOCK_LT(RTIMER_NOW(), wt + INTER_PACKET_INTERVAL)) { }
#else /* RDC_CONF_HARDWARE_ACK */
    /* Wait for the ACK packet */
    wt = RTIMER_NOW();
    while(RTIMER_CLOCK_LT(RTIMER_NOW(), wt + INTER_PACKET_INTERVAL)) { }
    //PRINTF("is_broadcast %d\n", is_broadcast);
    if(!is_broadcast && (NETSTACK_RADIO.receiving_packet() ||
                         NETSTACK_RADIO.pending_packet() ||
                         NETSTACK_RADIO.channel_clear() == 0)) {
      uint8_t ackbuf[ACK_LEN];
      wt = RTIMER_NOW();
      while(RTIMER_CLOCK_LT(RTIMER_NOW(), wt + AFTER_ACK_DETECTED_WAIT_TIME)) { }

      len = NETSTACK_RADIO.read(ackbuf, ACK_LEN);
      if(len == ACK_LEN && seqno == ackbuf[ACK_LEN - 1]) {
        got_packet_ack = 1;
        packet_pushed++;
        //PRINTF("lpprdc: ack received\n");
#if WITH_PHASE_OPTIMIZATION
        encounter_time = txtime;
#endif
      } else {
        PRINTF("lpprdc: collisions while sending, len %d, seqno %d, recseqno %d\n", len, seqno, ackbuf[ACK_LEN - 1]);
        collisions++;
      }
    } else if(!is_broadcast) {
      //PRINTF("lpprdc: no ack detected\n");
    }
#endif /* RDC_CONF_HARDWARE_ACK */
    } while (!packet_pushed++ || (is_broadcast && RTIMER_CLOCK_LT(RTIMER_NOW(), bt + max_probe_interval)));

    off();

#if CONTIKIMAC_CONF_COMPOWER
    /* Accumulate the power consumption for the packet transmission. */
    compower_accumulate(&current_packet);

    /* Convert the accumulated power consumption for the transmitted
       packet to packet attributes so that the higher levels can keep
       track of the amount of energy spent on transmitting the
       packet. */
    compower_attrconv(&current_packet);

    /* Clear the accumulated power consumption so that it is ready for
       the next packet. */
    compower_clear(&current_packet);
#endif /* CONTIKIMAC_CONF_COMPOWER */



  /*if(is_broadcast) {
    contikimac_is_on = contikimac_was_on;
    return MAC_TX_OK;
  }*/

/*  if(NETSTACK_RADIO.channel_clear()) {

  } else {
    PRINTF("lpprdc: collision while transmitting\n");
    collisions++;
  }*/



  /*PRINTF("lpprdc: send (strobes=%u, len=%u, %s, %s), done\n", strobes,
         packetbuf_totlen(),
         got_packet_ack ? "ack" : "no ack",
         collisions ? "collision" : "no collision");*/


    contikimac_is_on = contikimac_was_on;
    we_are_sending = 0;

    /* Determine the return value that we will return from the
       function. We must pass this value to the phase module before we
       return from the function.  */
    if(collisions > 0) {
      ret = MAC_TX_COLLISION;
    } else if(!is_broadcast && !got_packet_ack) {
      ret = MAC_TX_NOACK;
    } else {
      ret = MAC_TX_OK;
    }

#if WITH_PHASE_OPTIMIZATION
    if(is_known_receiver && got_packet_ack) {
      PRINTF("no miss %d wake-ups %d\n",
	     packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[0],
             strobes);
    }

    if(!is_broadcast) {
      if(collisions == 0 && is_receiver_awake == 0) {
        phase_update(packetbuf_addr(PACKETBUF_ADDR_RECEIVER),
	  	   encounter_time, ret);
      }
    }
#endif /* WITH_PHASE_OPTIMIZATION */

    if(ret != MAC_TX_DEFERRED) {
      queuebuf_to_packetbuf(curr_packet_list->buf);
      mac_call_sent_callback(curr_callback, curr_ptr, ret, 1);
    }

    if(ret == MAC_TX_OK) {
      if(next != NULL) {
        /* We're in a burst, no need to wake the receiver up again */
        is_receiver_awake = 1;
        curr_packet_list = next;
      }
    } else {
      /* The transmission failed, we stop the burst */
      next = NULL;
    }
  } while((next != NULL) && pending);

  we_are_listening = 0;

  PT_END(&send_pt);
}
/*---------------------------------------------------------------------------*/
static void
qsend_list(mac_callback_t sent, void *ptr, struct rdc_buf_list *buf_list)
{
  struct rdc_buf_list *curr;
  struct rdc_buf_list *next;
  int ret;
  int pending;

  if(buf_list == NULL) {
    return;
  }

  /* Do not send during reception of a burst */
  //TODO: if we're listening we should be able to just add these packets to the queue
  if(we_are_receiving_burst || we_are_listening) {
    printf("failed qsend\n");
    /* Prepare the packetbuf for callback */
    queuebuf_to_packetbuf(buf_list->buf);
    /* Return COLLISION so the MAC may try again later */
    mac_call_sent_callback(sent, ptr, MAC_TX_COLLISION, 1);
    return;
  }

  /* Create and secure frames in advance */
  curr = buf_list;
  do {
    next = list_item_next(curr);
    queuebuf_to_packetbuf(curr->buf);
    if(!packetbuf_attr(PACKETBUF_ATTR_IS_CREATED_AND_SECURED)) {
      /* create and secure this frame */
      if(next != NULL) {
        packetbuf_set_attr(PACKETBUF_ATTR_PENDING, 1);
      }
#if !NETSTACK_CONF_BRIDGE_MODE
      /* If NETSTACK_CONF_BRIDGE_MODE is set, assume PACKETBUF_ADDR_SENDER is already set. */
      packetbuf_set_addr(PACKETBUF_ADDR_SENDER, &linkaddr_node_addr);
#endif
      packetbuf_set_attr(PACKETBUF_ATTR_MAC_ACK, 1);
      if(NETSTACK_FRAMER.create() < 0) {
        PRINTF("lpprdc: framer failed\n");
        mac_call_sent_callback(sent, ptr, MAC_TX_ERR_FATAL, 1);
        return;
      }

      packetbuf_set_attr(PACKETBUF_ATTR_IS_CREATED_AND_SECURED, 1);
      queuebuf_update_from_packetbuf(curr->buf);
    }
    curr = next;
  } while(next != NULL);

  /* The receiver needs to be awoken before we send */
  is_receiver_awake = 0;
  curr_packet_list = buf_list;
  curr_callback = sent;
  curr_ptr = ptr;
  send_packet();
}
/*---------------------------------------------------------------------------*/
static void
qsend_packet(mac_callback_t sent, void *ptr)
{
  static struct rdc_buf_list list;
  list.next = NULL;
  list.buf = queuebuf_new_from_packetbuf();
  list.ptr = NULL;
  qsend_list(sent, ptr, &list);
}
/*---------------------------------------------------------------------------*/
/* Timer callback triggered when receiving a burst, after having
   waited for a next packet for a too long time. Turns the radio off
   and leaves burst reception mode */
static void
recv_burst_off(void *ptr)
{
  off();
  we_are_receiving_burst = 0;
}
/*---------------------------------------------------------------------------*/
static void
input_packet(void)
{
  static struct ctimer ct;
  int duplicate = 0;
  int is_broadcast = 0;

#if CONTIKIMAC_SEND_SW_ACK
  int original_datalen;
  uint8_t *original_dataptr;

  original_datalen = packetbuf_datalen();
  original_dataptr = packetbuf_dataptr();
#endif
  //PRINTF("?\n");
  
  if(!we_are_receiving_burst && !we_are_probing && !we_are_listening) {
    off();
  }
  
  if(packetbuf_datalen() == ACK_LEN) {
    /* Ignore ack packets */
    //PRINTF("lpprdc: ignored ack\n");
    return;
  }

  if(packetbuf_totlen() > 0 && NETSTACK_FRAMER.parse() >= 0) {
    //PRINTF("lpprdc: input called. is broadcast? %d\n", packetbuf_holds_broadcast());
    //PRINTF("lpprdc: receiver %d.%d.\n", packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[1], packetbuf_addr(PACKETBUF_ADDR_RECEIVER)->u8[0]);
    //PRINTF("lpprdc: datalen %d\n", packetbuf_datalen());
    if(packetbuf_datalen() == PROBE_LEN) {
      if(we_are_listening && (we_are_broadcasting || linkaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_SENDER), &current_receiver_addr))) {
        //PRINTF("lpprdc: probe from receiver\n");
        is_receiver_awake = 1;
        send_packet();
        //process_post_synch(&send_packet_process, PROCESS_EVENT_CONTINUE, NULL);
      } else {
        //PRINTF("lpprdc: ignored beacon\n");
      }
      return;
    }

    is_broadcast = packetbuf_holds_broadcast();
    if(packetbuf_datalen() > 0 &&
       packetbuf_totlen() > 0 &&
       (linkaddr_cmp(packetbuf_addr(PACKETBUF_ADDR_RECEIVER),
                     &linkaddr_node_addr) ||
        is_broadcast)) {
      /* This is a regular packet that is destined to us or to the
         broadcast address. */
      //PRINTF("lpprdc: packet received, broadcast: %d\n", packetbuf_holds_broadcast());

      /* If FRAME_PENDING is set, we are receiving a packets in a burst */
      we_are_receiving_burst = packetbuf_attr(PACKETBUF_ATTR_PENDING);
      if(we_are_receiving_burst) {
        on();
        /* Set a timer to turn the radio off in case we do not receive
	   a next packet */
        ctimer_set(&ct, INTER_PACKET_DEADLINE, recv_burst_off, NULL);
      } else {
        //PRINTF("lpprdc: packet received, not burst, radio off\n");
        if(!we_are_listening) {
          off();
        }
        ctimer_stop(&ct);
      }

#if RDC_WITH_DUPLICATE_DETECTION
      /* Check for duplicate packet. */
      duplicate = mac_sequence_is_duplicate();
      if(duplicate) {
        /* Drop the packet. */
        //PRINTF("lpprdc: Drop duplicate\n");
      } else {
        mac_sequence_register_seqno();
      }
#endif /* RDC_WITH_DUPLICATE_DETECTION */

#if CONTIKIMAC_CONF_COMPOWER
      /* Accumulate the power consumption for the packet reception. */
      compower_accumulate(&current_packet);
      /* Convert the accumulated power consumption for the received
         packet to packet attributes so that the higher levels can
         keep track of the amount of energy spent on receiving the
         packet. */
      compower_attrconv(&current_packet);

      /* Clear the accumulated power consumption so that it is ready
         for the next packet. */
      compower_clear(&current_packet);
#endif /* CONTIKIMAC_CONF_COMPOWER */

      //PRINTDEBUG("lpprdc: data (%u)\n", packetbuf_datalen());

#if CONTIKIMAC_SEND_SW_ACK
      {
        frame802154_t info154;
        frame802154_parse(original_dataptr, original_datalen, &info154);
        if(info154.fcf.frame_type == FRAME802154_DATAFRAME &&
            info154.fcf.ack_required != 0 &&
            linkaddr_cmp((linkaddr_t *)&info154.dest_addr,
                &linkaddr_node_addr)) {
          uint8_t ackdata[ACK_LEN] = {0, 0, 0};

          we_are_sending = 1;
          ackdata[0] = FRAME802154_ACKFRAME;
          ackdata[1] = 0;
          ackdata[2] = info154.seq;
          NETSTACK_RADIO.send(ackdata, ACK_LEN);
          we_are_sending = 0;
        }
      }
#endif /* CONTIKIMAC_SEND_SW_ACK */

      if(!duplicate) {
        NETSTACK_MAC.input();
      }
      return;
    } else {
      PRINTDEBUG("lpprdc: data not for us\n");
      off();
    }
  } else {
    //PRINTF("lpprdc: failed to parse (%u)\n", packetbuf_totlen());
  }
}
/*---------------------------------------------------------------------------*/
static void
init(void)
{
  radio_value_t radio_tx_mode = 0;
  /*if(NETSTACK_RADIO.get_value(RADIO_PARAM_TX_MODE, &radio_tx_mode) != RADIO_RESULT_OK) {
    PRINTF("lpprdc: failed to get radio params, aborting\n");
    return;
  }
  radio_tx_mode &= ~RADIO_TX_MODE_SEND_ON_CCA;
  if(NETSTACK_RADIO.set_value(RADIO_PARAM_TX_MODE, radio_tx_mode) != RADIO_RESULT_OK) {
    PRINTF("lpprdc: failed to set radio params, aborting\n");
    return;
  }*/
  radio_is_on = 0;

  packetbuf_clear();
  packetbuf_set_addr(PACKETBUF_ADDR_RECEIVER, &linkaddr_null);
  packetbuf_set_addr(PACKETBUF_ADDR_SENDER, &linkaddr_node_addr);

  if(NETSTACK_FRAMER.create() < 0) {
    PRINTF("lpprdc: framer failed for probe, aborting\n");
    return;
  }
  probe_len = packetbuf_totlen();
  //probe_buf = queuebuf_new_from_packetbuf();
  //memcpy(packetbuf_hdrptr(), probebuf, probe_len);
  packetbuf_copyto(probebuf);

  memb_init(&addr_list_memb);

  /*if(probe_rate != 0) {
  probe_rate = 64;
  PRINTF("lpprdc: sink duty cycle set\n");
  probe_interval = RTIMER_ARCH_SECOND / probe_rate;
  } else {*/
  probe_rate = NETSTACK_RDC_CHANNEL_CHECK_RATE;
  probe_interval = CLOCK_SECOND / probe_rate;
  ctimer_max_probe_interval = probe_interval + probe_interval / NETSTACK_RDC_CHANNEL_CHECK_RANDOMNESS_FRACTION;
  max_probe_interval = RTIMER_ARCH_SECOND / CLOCK_SECOND * ctimer_max_probe_interval;
  listen_for_probe_timeout = 3*ctimer_max_probe_interval;
  //}

  PT_INIT(&pt);
  PT_INIT(&send_pt);
  //process_start(&listen_for_probe_process, NULL);

  //rtimer_set(&rt, RTIMER_NOW() + probe_interval, 1, powercycle_wrapper, NULL);
  ctimer_set(&probe_timer, probe_interval, powercycle, NULL);

  contikimac_is_on = 1;

#if WITH_PHASE_OPTIMIZATION
  phase_init();
#endif /* WITH_PHASE_OPTIMIZATION */

}
/*---------------------------------------------------------------------------*/
static int
turn_on(void)
{
  if(contikimac_is_on == 0) {
    contikimac_is_on = 1;
    contikimac_keep_radio_on = 0;
    rtimer_set(&rt, RTIMER_NOW() + probe_interval, 1, powercycle_wrapper, NULL);
  }
  return 1;
}
/*---------------------------------------------------------------------------*/
static int
turn_off(int keep_radio_on)
{
  contikimac_is_on = 0;
  contikimac_keep_radio_on = keep_radio_on;
  if(keep_radio_on) {
    radio_is_on = 1;
    return NETSTACK_RADIO.on();
  } else {
    radio_is_on = 0;
    return NETSTACK_RADIO.off();
  }
}
/*---------------------------------------------------------------------------*/
static unsigned short
duty_cycle(void)
{
  return (1ul * CLOCK_SECOND / probe_rate);
}
/*---------------------------------------------------------------------------*/
const struct rdc_driver lpprdc_driver = {
  "LPP-RDC",
  init,
  qsend_packet,
  qsend_list,
  input_packet,
  turn_on,
  turn_off,
  duty_cycle,
};
/*---------------------------------------------------------------------------*/
uint16_t
lpprdc_debug_print(void)
{
  return 0;
}
/*---------------------------------------------------------------------------*/
